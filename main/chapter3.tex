%!TEX root = ../my_thesis.tex

\renewcommand{\curChapter}{main/chapter3}

\chapter{\AFFECT: A Fast Forward Error Correction Toolbox}
\label{chap:aff3ct}

This chapter is dedicated to the introduction of our \AFFECT open-source
toolbox. The first section describes the main prerequisites driven by four
objectives: high performance software implementation, support for algorithmic
heterogeneity, portability and reproducibility. In the second section, \AFFECT
is compared with the other existing \verb|C|/\Cxx FEC software libraries. The
third section presents \AFFECT as a library dedicated to the digital
communication algorithms. The software architecture and functionalities are
described. Then, examples of library use are given in \Cxx and MATLAB\R. The
fourth section focuses on the \AFFECT BER/FER simulator that comes with the
toolbox. A tour of the possible explorations is given and our BER/FER comparator
is presented. At the end, the \AFFECT testing strategy is explained. The fifth
section shows the impact of \AFFECT in industrial and academic contexts. A
review of the scientific publications that used \AFFECT is given. The last
section concludes this chapter.

\vspace*{\fill}
\minitoccustom
\vspace*{\fill}

\newpage
\section{Prerequisites}

\AFFECT for \emph{A Fast Forward Error Correction Toolbox} is a set of tools
regrouping all the contributions of this thesis and more. In this section, we
explain how \AFFECT answers to the different problematics defined in
Section~\ref{sec:ctx_problematics}.

\subsection{High Performance Implementations}

The signal processing community mainly writes source codes with high level
languages like MATLAB\R or Python. These languages enable to write
implementations close to the pseudo-code but an important part of the CPU
computational power is wasted. When targeting low error-rate functional
simulations or real-time constraints (like for the C-RAN and the SDR), these
high level languages are not suitable. With the increasing complexity of the
digital communication systems it becomes crucial to have high performance
implementations.

To this purpose, \AFFECT is mainly written in \Cxx~\cite{Stroustrup2013}. This
choice has been made to focus on high performance implementations without
sacrificing too much the expressiveness. \Cxx is a compiled language, it enables
very low level programming paradigms like intrinsics functions (or even assembly
code) as well as high level concepts like the Object-Oriented Programming (OOP)
paradigm. Moreover, \Cxx comes with the template meta-programming technique
to facilitate the programming at compile time. Another main advantage of \Cxx is
that it is constantly evolving~\cite{Stroustrup2020} and it is well-spread in
the HPC community. However, we choose to limit the utilization of \Cxx to its
2011 version (\Cxy{11}). This choice has been made for two main reasons: 1) to
maximize the compatibility with the installed compilers in various environments;
2) \Cxy{11} features are sufficient for digital communication systems.

For the signal processing algorithms implemented in \AFFECT, we observed that
compared to interpreted languages, the speedups range from 10 to 1000 in \Cxx.
If we consider the heavily optimized implementations presented in
Chapter~\ref{chap:opt}, the speedups are closer to 1000. Of course the speedups
are not simply coming from the porting of the MATLAB\R code to the \Cxx code. It
is true that the compiler is sometime able to perform optimizations that can
benefit for the overall performance. But, most of the speedup comes from
dedicated implementations. \Cxx enables source code implementations to take
advantage of the hardware architecture. Moreover, it is up to the developer to
exploit his/her knowledge of the CPU architecture in the design process. As
explained in Chapter~\ref{chap:opt}, optimizations like the vectorization, the
choice of an adapted data layout and the loop unrolling are the keys of the
proposed high performance software implementations.

\subsection{Support for Algorithmic Heterogeneity}

As shown in Chapter~\ref{chap:ctx}~and~\ref{chap:opt}, there are many signal
processing algorithms along with many possible implementations. A summary list
of the algorithms supported by \AFFECT is given in the next section. It
motivates the need to regroup and package all these algorithms in a common
toolbox. The main interests are 1) to propose common and homogeneous interfaces
to the users and 2) to maximize code reuse among implementations.

In the context of the channel codes, the algorithmic heterogeneity is
challenging. Actually, each family has its own specificities. This is why in
most existing projects the focus is made on a single code family (see
Section~\ref{sec:aff3ct_related_works}). This strongly motivated the need of a
toolbox like \AFFECT. The objective is to homogenize the use of various FEC code
families.

\MIPP is an example of code reuse as it defines elementary blocks used
everywhere in \AFFECT. Other macro blocks are also often reused like the
reordering process proposed in Sections~\ref{sec:opt_vec_inter}. There are many
other macro blocks in \AFFECT similar to the ones that are presented in the
manuscript. This enables to speedup and facilitate the implementation of new
efficient algorithms.

\subsection{Portability}

Portability is a main concern in \AFFECT. The signal community use multiple
operating systems. The predominant ones are Windows, macOS and Linux. Thanks to
the \Cxy{11} standard library, the same \AFFECT source code can be compiled on
these three operating systems. It is possible to compile with the GNU compiler
(GCC), the Clang compiler, the Intel\R \Cxx compiler (ICPC) and the Microsoft\R
Visual compiler (MSVC). Note that other operating systems and compilers may also
work as long as they are compatible with the \Cxy{11} standard.

\AFFECT also takes advantage of various common CPU architectures like
Intel\R/AMD\R and ARM\R processors. The Intel\R/AMD\R CPUs are widely spread
in current laptops as well as in the clusters (or in the supercomputers). ARM\R
CPUs are interesting as they are generally consuming less energy than
Intel\R/AMD\R CPUs. They are good candidates for embedded systems. Moreover,
they are more and more present in HPC contexts. At the time of the writing,
Fugaku, the most powerful supercomputer in the world, is based on ARM CPUs.

The heterogeneity of the CPU architectures is mainly managed by \MIPP (see
Section~\ref{sec:opt_mipp}). The compiled binary is dedicated to the appropriate
SIMD ISA. If the architecture is not recognized then the \AFFECT binary
falls back to a sequential version.

\subsection{Reproducibility}

In the signal processing community it is not common to share the resulting
implementations of a scientific publication. Thus, it is sometime a tedious task
to reproduce the state-of-the-art results. Consequently, the community spends a
non-negligible amount of time in ``reinventing the wheel''. We think this should
be avoided, thus \AFFECT is an open source toolbox coming with a permissive MIT
license. This way, industrial and academic actors can invest themselves and
reuse parts of \AFFECT in their own projects without any restrictions. The
diffusion of \AFFECT is discussed in Section~\ref{sec:aff3ct_impact}.

Even when a code is fully open, there is no guarantee that the achieved results
can be reproduced as the code is constantly evolving. Any modification of the
source code can break features that were working before. This problem is
inherent to all living projects. To prevent regressions as much as possible, a
full pipeline of tests has been created. It is detailed in
Section~\ref{sec:aff3ct_ci_cd}. Each time someone makes a modification on the
\AFFECT source code, then the pipeline of tests is triggered. The
reproducibility of the results is based on the fact that for a given \AFFECT
simulator command line, the output BER/FER decoding performance should always be
the same. In other terms, the \AFFECT simulator is deterministic.

\section{Related Works}
\label{sec:aff3ct_related_works}

\begin{table}[htp]
  \centering
  \caption{\C/\Cxx open source channel coding simulators/libraries.}
  \label{tab:aff3ct_fec_libraries_comparison}
  {\resizebox{\linewidth}{!}{
  \begin{tabular}{r   r  r  r  r  r | C{\simcolwidth}  C{\simcolwidth}  C{\simcolwidth}  C{\simcolwidth}  C{\simcolwidth}  C{\simcolwidth}  C{\simcolwidth}  C{\simcolwidth}  C{\simcolwidth}  C{\simcolwidth} }
  \multirow{4}{*}{\textbf{Name}} & \multirow{4}{*}{\textbf{Ref.}} &                  &                &                & \multirow{4}{*}{\textbf{License}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{Polar}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{LDPC}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{Turbo}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{Turbo P.}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{BCH}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{RS}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{Conv.}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{RA}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{Rep.}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{Erasure}} \\
                                 &                                & \textbf{Contri-} & \textbf{Code}  & \textbf{Start} &                                   &        &        &        &        &        &        &        &        &        &         \\
                                 &                                & \textbf{butors}  & \textbf{Lines} & \textbf{Year}  &                                   &        &        &        &        &        &        &        &        &        &         \\
                                 &                                &                  &                &                &                                   &        &        &        &        &        &        &        &        &        &         \\ \hline\hline
                                                                                                                                                           % Polar    LDPC     Turbo    TPC      BCH      RS       Conv.    RA       Rep.     Erasure
  {\AFFECT}                      & \cite{Cassagne2019a}           &               11 &            76k & 2016           & MIT                               & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \xmark  \\
  {aicodix GmbH}                 & \cite{Aicodix}                 &                1 &             7k & 2018           & Copyright                         & \xmark & \cmark & \xmark & \xmark & \cmark & \cmark & \xmark & \xmark & \xmark & \xmark  \\
  {eccpage}                      & \cite{ECCpage}                 &               20 &              - & 1989           & -                                 & \xmark & \cmark & \cmark & \xmark & \cmark & \cmark & \cmark & \xmark & \xmark & \cmark  \\
  {EZPWD}                        & \cite{EZPWDRS}                 &                2 &             6k & 2014           & GPLv3                             & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark  \\
  {FastECC}                      & \cite{FastECC}                 &                2 &             1k & 2015           & Apache 2.0                        & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark  \\
  {FEC-AL}                       & \cite{FEC-AL}                  &                1 &             3k & 2018           & BSD                               & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark & \xmark & \xmark & \cmark  \\
  {FECpp}                        & \cite{FECpp}                   &                1 &             2k & 2009           & -                                 & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark  \\
  {GNURadio}                     & \cite{GNURadio}                &              192 &           270k & 2006           & GPLv3                             & \cmark & \cmark & \xmark & \xmark & \xmark & \xmark & \cmark & \xmark & \cmark & \xmark  \\
  {Inan}                         & \cite{Inan-LDPC}               &                2 &            13k & 2018           & Copyright                         & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark  \\
  {IT++}                         & \cite{ITpp}                    &               20 &           109k & 2005           & GPLv3                             & \xmark & \cmark & \cmark & \xmark & \cmark & \cmark & \cmark & \xmark & \xmark & \xmark  \\
  {Le Gal}                       & \cite{LeGal-LDPC}              &                1 &            83k & 2015           & -                                 & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark  \\
  {Leopard}                      & \cite{Leopard}                 &                4 &             5k & 2017           & BSD                               & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark  \\
  {libcorrect}                   & \cite{Libcorrect}              &                6 &             5k & 2016           & BSD                               & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark & \cmark & \xmark & \xmark & \xmark  \\
  {Neal}                         & \cite{Neal-LDPC}               &                1 &             5k & 2006           & Copyright                         & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark  \\
  {OpenAir}                      & \cite{OpenAir}                 &              148 &           740k & 2013           & OAI Public                        & \xmark & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark  \\
  {OpenFEC}                      & \cite{OpenFEC}                 &                8 &            55k & 2009           & CeCCIL-C                          & \xmark & \cmark & \xmark & \xmark & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark  \\
  {Schifra}                      & \cite{Schifra}                 &                1 &             7k & 2010           & GPLv3                             & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark  \\
  {Siamese}                      & \cite{Siamese}                 &                1 &            11k & 2018           & BSD                               & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark & \xmark & \xmark & \cmark  \\
  {Tavildar (Polar)}             & \cite{Tavildar-Polar}          &                1 &             2k & 2016           & -                                 & \cmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark  \\
  {Tavildar (LDPC)}              & \cite{Tavildar-LDPC}           &                1 &             1k & 2016           & -                                 & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark  \\
  {the-art-of-ecc}               & \cite{The-art-of-ecc}          &                1 &              - & 2006           & Copyright                         & \xmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \xmark & \xmark & \xmark  \\
  {TurboFEC}                     & \cite{TurboFEC}                &                2 &             4k & 2015           & GPLv3                             & \xmark & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark  \\
  \end{tabular}
  }}
\end{table}

In the digital signal processing community, many researchers implement their own
simulation chain to validate their works.
Table~\ref{tab:aff3ct_fec_libraries_comparison} presents, to the best of our
knowledge, a list of currently available \verb|C|/\Cxx open source channel
coding simulators/libraries. This comparison table is also available
online where it is regularly updated\footnote{\texttt{C}/\Cxx Open Source FEC
Libraries: \url{http://aff3ct.github.io/fec_libraries.html}}. We choose to
compare with projects compiled as binaries, since they aim at high throughput
and low latency, as \AFFECT. Many open source projects in Python or in MATLAB\R
exist as well. But these tools are usually slower than compiled binaries, and
rather aim at prototyping.

Table~\ref{tab:aff3ct_fec_libraries_comparison} shows that, generally, the
\verb|C|/\Cxx FEC libraries target a single family or a small subset of channel
codes. As a consequence, a large effort is spent to re-develop similar features,
since all those libraries and tools share many characteristics (except the
channel code itself). \AFFECT attempts to lower this redundancy by offering a
full simulator/library that consistently supports a wide range of channel codes
and homogenizes usage (command line, \Cxx interfaces, etc.) across all code
families. One can observe that \AFFECT is the only library to support the LDPC
codes, the polar codes and the turbo codes. These three channel codes are known
to be the most challenging ones to implement.

\section{Library of Digital Communication Algorithms}

\subsection{Software Architecture}
\label{sec:aff3ct_archi}

\AFFECT is developed in \Cxx in an object-oriented programming style. It
provides fundamental classes involved in the building of digital communication
chains. For instance, in Fig~\ref{fig:ctx_simu_com_chain}, the source, the
encoder, the modulator, the channel, the demodulator, the decoder and the
monitor are module classes. Tools can be classes or functions. For instance, the
polar API presented in Section~\ref{sec:opt_polar_api} is a static class
implementing the polar $f$, $g$ and $h$ functions (see
Equation~\ref{eq:ctx_polar_f_g_h}) that are common to all the polar decoders.
Many implementations of defined interfaces can coexist. For instance, the
abstract \verb|Encoder| class that defines the \verb|encode| pure virtual
method. The \verb|encode| method takes a vector $\bm{u}$ of $K$ bits as inputs
and outputs a vector $\bm{c}$ of $N$ bits. Then, there are many implementations
of the \verb|Encoder| class like the \verb|Encoder_polar| class, the
\verb|Encoder_LDPC| class, the \verb|Encoder_turbo| class, etc. To simplify the
instanciation of the non-static classes (like the encoders), many factory
classes have been created. Their job is to simplify the allocation of the module
and tool objects.

\subsubsection{Module}

All the classes that implement communication chain elements inherit from the
\verb|Module| abstract class. The particularity of the module classes is that
they have to expose at least one method that can be called in the context of
digital communication chains. These specific methods are called \emph{tasks}.
A task is an elementary processing performed on some data. For instance, the
\verb|Encoder| class inherits from the \verb|Module| class. It also defines the
\verb|encode| method which is a task. To be recognized as a task, the
\verb|encode| method has to be registered in the constructor of the
\verb|Encoder| class. The abstract \verb|Module| class defines and implements a
set of functions to perform this registering. Most of the time, when a developer
wants to add a new module, he does not need to register any task because it is
already done for him. For instance, if a developer wants to add a new encoder,
then he simply needs to inherit from the proposed \verb|Encoder| class and to
implement the \verb|encode| method. A task is characterized by its
\emph{sockets}. They are used to describe the input and output data of the task
following a philosophy close to \emph{ports} in component-based development
approaches. The socket type can be input or output. The sockets also enable to
automatically allocate the data. In \AFFECT the convention is to automatically
allocate the data of the output sockets.

\subsubsection{Tools}

The tools regroups many different types of processing:
\begin{itemize}
  \item \textbf{Algorithmic \& Math}: the algorithmic components focus on the
    implementation of traditional algorithmic structures. For instance, this
    contains implementations of trees, matrices, histograms, etc. It also
    contains sorting and PRNG algorithm implementations. The math components
    regroup the interpolations, the Galois fields, the distributions, the
    integrations, etc.;
  \item \textbf{Channel code}: this type of tools regroups the processing
    implementations that are common to a single code family. For instance, the
    \verb|Polar_API| is located here;
  \item \textbf{Display}: these components are classes and functions dedicated
    to the display of the information in the terminal or in files. Statistic
    functions are located here as well as classes dedicated to the display of
    the BER and the FER performances;
  \item \textbf{Interface}: these abstract classes define interfaces. For
    instance, the \verb|Interface_reset| proposes a common interface for the
    \verb|reset| method. This way, all the classes inhering from this interface
    have exactly the same prototype for their implementation of the \verb|reset|
    method;
  \item \textbf{Performance}: this type of components is dedicated to high
    performance implementation. The vectorized reordering process presented in
    Section~\ref{sec:opt_vec_inter} is located here.
\end{itemize}
The above list is not exhaustive but is intended to give a representative
overview of what can be found in the different tools.

\subsubsection{Factory}

In \AFFECT, one has to allocate modules dynamically at runtime. Combined with
the fact that there are many possible combinations of modules, we applied the
factory pattern. In the OOP paradigm, the factory method pattern is dedicated to
the the problem of creating objects without having to specify the exact class of
the object that will be created. This is done by calling a method on the
factory. In \AFFECT, all the factories propose a \verb|build| method to this
purpose. The return type of the \verb|build| method is always an abstract class
that regroups a sub-set of implemented classes. Considering the factory
\verb|Source| class, first the instantiation of this class is required. Then,
the created object comes with a list of public members that can be manually set
or deduced from the command line arguments. Once this is done the \verb|build|
method can be called. This method makes use of the public members (previously
set) of the object to instantiate an object of the module \verb|Source| class.
This object can be a \verb|Source_random| object, a \verb|Source_user_binary|
object, etc.

\subsection{Examples of Library Use}
\label{sec:aff3ct_library_example}

As a FEC library, \AFFECT can be used programmatically in real-time contexts or
to build specific functional simulations. \AFFECT blocks can also be operated in
external projects without restriction. In this section we propose two
illustrative examples of the \AFFECT library usage. The first one is dedicated
to the simulation of a digital communication chain while the second focuses on
the validation of a hardware decoder.

\paragraph{Simulation of a Digital Communication Chain}

\begin{figure}[htp]
  \centering
  \includegraphics[scale=0.9]{\curChapter/fig/use_cases/library_task_module/library_task_module}
  \caption{Simulation of a digital communication chain using the \AFFECT
    library.}
  \label{fig:aff3ct_library_task_module}
\end{figure}

\begin{listing}[htp]
  \inputminted[frame=lines,linenos]{C++}{\curChapter/src/use_cases/library/modules_allocation.cpp}
  \caption{Example of modules allocation with the \AFFECT library.}
  \label{lst:aff3ct_library_modules_allocation}
\end{listing}
\begin{listing}[htp]
  \inputminted[frame=lines,linenos]{C++}{\curChapter/src/use_cases/library/sockets_binding.cpp}
  \caption{Example of sockets binding with the \AFFECT library.}
  \label{lst:aff3ct_library_sockets_binding}
\end{listing}
\begin{listing}[htp]
  \inputminted[frame=lines,linenos]{C++}{\curChapter/src/use_cases/library/tasks_execution.cpp}
  \caption{Example of tasks execution with the \AFFECT library.}
  \label{lst:aff3ct_library_tasks_execution}
\end{listing}

A simulation chain that can be implemented is given in
Figure~\ref{fig:aff3ct_library_task_module}. The represented modules an tasks
correspond to the classes and methods presented in the previous section. For
instance, the \textit{modem} module contains the \textit{modulate} and
\textit{demodulate} tasks. Figure~\ref{fig:aff3ct_library_task_module} presents
common modules and tasks typically found in a typical digital communication
chain. It shows that the number of tasks per module can vary depending on the
module type. The first step is to allocate the modules. In
Listing~\ref{lst:aff3ct_library_modules_allocation} we chose to allocate modules
on the stack. But it is also possible to do the same on the heap. $K$ is the
number of information bits, $N$ is the frame size and $E$ is the number of
erroneous frames to simulate. In this basic example, a repetition code is
selected, it simply repeats the information bits $N/K$ times. The next step is
to bind the sockets of successive tasks together (see
Listing~\ref{lst:aff3ct_library_sockets_binding}). To propose an easy to use
interface, sockets and tasks can be selected through the \verb|[]| operator,
which takes a \Cxx strongly typed enumerate. This way it is possible to
specialize the code depending on whether it is a socket or a task. Strongly
typed enumerates are checked at compile time (contrary to standard enumerates),
making it impossible to use wrong values. For instance, in the example, the
\textit{source} module output socket \verb|module::src::sck::generate::u| is
connected to the input socket \verb|module::enc::sck::encode::u| of the
\textit{encoder}. The simulation is then started and each task is executed. In
Listing~\ref{lst:aff3ct_library_tasks_execution}, the whole communication chain
is executed multiple times, until the $E = 100$ frame error limit is reached.
Complete examples are available on
GitHub\footnote{\AFFECT library examples: \url{https://github.com/aff3ct/my_project_with_aff3ct/}}.

\paragraph{Validation of a Hardware Decoder}

The \AFFECT library has also been used to prototype FPGA decoders.
In~\cite{Cassagne2017a}, a BCH decoder is implemented on a Xilinx\R Artix-7
FPGA. \AFFECT simulates the transmission of a first frame. The noisy frame is
then sent to the FPGA using the UART protocol. The hardware BCH decoder
processes the frame and sends it back to the PC. \AFFECT can then perform the
rest of the processing for this frame. Once the number of residual errors is
updated, \AFFECT starts with a new frame, and so on. The decoding performance
matches to the performance of the pure software simulation which shows that the
hardware BCH decoder is correctly implemented. This process is also known as
\emph{hardware in the loop}.

\subsection{MATLAB\R Wrapper}

In the signal processing community it is common to exploit MATLAB\R to implement
and to evaluate new algorithms or/and configurations. More specifically, the
\emph{Communications Toolbox} is often used. This toolbox contains a larger set
of digital communication algorithms than \AFFECT. But they often lack of
efficiency, especially for the channel decoder implementations. Knowing that, a
MATLAB\R wrapper has been proposed to be interfaced to the compiled \AFFECT
library. The wrapper can be seen as a new MATLAB\R toolbox that proposes faster
decoder implementations than the traditional MATLAB\R communications toolbox.
\AFFECT also comes with channel decoders that are not available in the standard
communications toolbox.

\begin{listing}[htp]
  \inputminted[frame=lines,linenos]{matlab}{\curChapter/src/use_cases/library/repetition_chain.m}
  \caption{Example of the \AFFECT MATLAB\R wrapper.}
  \label{lst:aff3ct_library_matlab}
\end{listing}

The proposed MATLAB\R wrapper is automatically generated for the \AFFECT
headers. The Clang compiler is used to generate the Abstract Syntax Tree (AST)
of the \AFFECT source code. A Python script extracts useful classes and methods.
These data are stored in a JSON database. Then, another Python script has been
written to generate \Cxx and MATLAB\R codes. It effectively performs the
interfaces between the \AFFECT library and MATLAB\R.
Listing~\ref{lst:aff3ct_library_matlab} shows the same example of code as in
Section~\ref{sec:aff3ct_library_example} written in MATLAB\R. At the time of the
writing, the MATLAB\R wrapper has not been publicly released yet.

\subsection{Software Functionalities}
\label{sec:aff3ct_features}

The \AFFECT software functionalities are decomposed in three main parts: the
\textit{codecs}, the \textit{modems} and the \textit{channels}.

\begin{table}[htp]
  \centering
  \caption{List of the channel codes (codecs) supported in \AFFECT.}
  \label{tab:aff3ct_features_codecs}
  \begin{tabular}{ c | c | c }
  \multirow{2}{*}{\textbf{Channel Code}}  & \multirow{2}{*}{\textbf{Standard}} & \multirow{2}{*}{\textbf{Decoders}}        \\
                                          &                                    &                                           \\
  \hline
  \hline
  \multirow{5}{*}{{LDPC}}                 & 5G (data), Wi-Fi,                  & Scheduling: Flooding and H./V. Layered    \\
                                          & WiMAX, WRAN,                       & Sum-Product Algorithm (SPA, log-SPA)      \\
                                          & 10 Gigabit Eth.,                   & Min-Sum its derivatives (MS, NMS and OMS) \\
                                          & DVB-S2, CCSDS                      & Approximate Min-Star (AMS)                \\
                                          & etc.                               & Bit Flipping: GallagerA/B/E, PPBF, WBF    \\
  \hline
                                          &                                    & Successive Cancellation (SC)              \\
  Polar                                   & 5G                                 & Successive Cancellation List (SCL)        \\
  (\Arikan mono-kernel)                   & (control channel)                  & CRC-Aided SCL (CA-SCL, FA-SCL, PA-SCL)    \\
                                          &                                    & Soft Cancellation (SCAN)                  \\
  \hline
  Polar                                   &                                    & Successive Cancellation (SC)              \\
  (mono/multi-kernel                      & --                                 & Successive Cancellation List (SCL)        \\
  generic)                                &                                    & CRC-Aided SCL (CA-SCL, PA-SCL)            \\

  \hline
  \multirow{1}{*}{{Turbo}}                & LTE (3G, 4G),                      & Turbo BCJR                                \\
  (single and double                      & DVB-RCS,                           & Turbo BCJR + Early Termination (CRC)      \\
  binary)                                 & CCSDS, etc.                        & Post proc.: Flip aNd Check (FNC)          \\
  \hline
  \multirow{2}{*}{{Product}}              & \multirow{2}{*}{WiMAX (opt.)}      & \multirow{2}{*}{Turbo Chase-Pyndiah}      \\
                                          &                                    &                                           \\
  \hline
  \multirow{3}{*}{{BCH}}                  & CD, DVD,                           &                                           \\
                                          & SSD, DVB-S2,                       & Berlekamp-Massey + Chien search           \\
                                          & Bitcoin, etc.                      &                                           \\
  \hline
  \multirow{3}{*}{{Reed-Solomon}}         & CD, DVD,                           &                                           \\
                                          & SSD, DVB-T,                        & Berlekamp-Massey + Chien search           \\
                                          & ADSL, etc.                         &                                           \\
  \hline
  \multirow{1}{*}{{Convolutional}}        &                                    & BCJR - Maximum A Posteriori (MAP)         \\
  (single and double                      & NASA                               & BCJR - Linear Approximation (L-MAP)       \\
  binary)                                 &                                    & BCJR - Max-log Approximation (ML-MAP)     \\
  \end{tabular}
\end{table}

The codecs are the main part of the toolbox. There is a broad range of supported
codes listed in Table~\ref{tab:aff3ct_features_codecs}. They naturally encompass
the encoders and decoders. But they can also include puncturing patterns to
shorten frame length according to some communication standards. Most of the
codec algorithms come from the literature, while the others have been designed
under \AFFECT~\cite{Tonnellier2016a,Tonnellier2016b,Tonnellier2017,
Leonardon2019}. In channel coding, the decoder is the most time-consuming
process, compared to the puncturing and the encoding processes. This is why a
specific effort is put on ensuring the high computing performance of the
decoders. Most of the decoding algorithms have thus been optimized to satisfy
high throughput and low latency constraints~\cite{LeGal2015a,Cassagne2015c,
Cassagne2016a,Cassagne2016b}. Those optimizations generally involve a vectorized
implementation, a tailored data quantization and the use of fixed-point
arithmetic.

\begin{table}[htp]
  \centering
  \caption{List of the modulations/demodulations (modems) supported in \AFFECT.}
  \label{tab:aff3ct_features_modems}
  \begin{tabular}{ c | c | c }
  \multirow{2}{*}{\textbf{Modem}} & \multirow{2}{*}{\textbf{Standard}} & \multirow{2}{*}{\textbf{Information}}  \\
                                  &                                    &                                        \\
  \hline
  \hline
  \multirow{3}{*}{{N-PSK}}        & IEEE 802.16 (WiMAX)                &                                        \\
                                  & UMTS (2G, 2G+)                     & Phase-Shift Keying                     \\
                                  & EDGE (8-PSK), ...                  &                                        \\
  \hline
  \multirow{3}{*}{{N-QAM}}        & IEEE 802.16 (WiMAX)                &                                        \\
                                  & UMTS (2G, 2G+)                     & Quadrature Amplitude Modulation        \\
                                  & 3G, 4G, 5G, ...                    &                                        \\
  \hline
  \multirow{3}{*}{{N-PAM}}        & IEEE 802.16 (WiMAX)                &                                        \\
                                  & UMTS (2G, 2G+)                     & Pulse Amplitude Modulation             \\
                                  & 3G, 4G, 5G, ...                    &                                        \\
  \hline
  \multirow{2}{*}{{CPM}}          & GMSK, Bluetooth                    & Continuous Phase Modulation            \\
                                  & IEEE 802.11 FHSS                   & Coded (convolutional-based) modulation \\
  \hline
  \multirow{2}{*}{{OOK}}          & IrDA (Infrared)                    & On-Off Keying                          \\
                                  & ISM bands                          & Used in optical communication systems  \\
  \hline
  \multirow{2}{*}{{SCMA}}         & \multirow{2}{*}{Considered for 5G} & Sparse Code Multiple Access            \\
                                  &                                    & Multi-user modulation                  \\
  \hline
  \multirow{2}{*}{{User defined}} & \multirow{2}{*}{-}                 & Constellation and order can be         \\
                                  &                                    & defined from an external file          \\
  \end{tabular}
\end{table}

In typical communication chains, it is necessary to adapt the digital signal
to the physical support. This operation is performed by the modulator and
conversely by the demodulator. \AFFECT comes with a rich set of modems to this
purpose. Table~\ref{tab:aff3ct_features_modems} lists all the supported modems.
\AFFECT supports several coded modulation/demodulation schemes like the
Continuous Phase Modulation (CPM)~\cite{Aulin1981a,Aulin1981b} and the Sparse
Code Multiple Access (SCMA) modulation~\cite{Nikopour2013,Ghaffari2017,
Ghaffari2019} with many codebooks~\cite{AlteraSCMA,Wu2015,Cheng2015,Zhang2016,
Klimentyev2016,Song2017,Klimentyev2017}). It enables to easily combine and
evaluate the channel codes with several types of modulations. In the case of the
CPM, analogical wave shapes are also simulated. The other modulation schemes are
at the digital level.

\begin{table}[htp]
  \centering
  \caption{List of the channel models supported in \AFFECT.}
  \label{tab:aff3ct_features_channels}
  \begin{tabular}{ c | c | c }
  \multirow{2}{*}{\textbf{Channel}}      & \multirow{2}{*}{\textbf{Multi-user}} & \multirow{2}{*}{\textbf{Information}}          \\
                                         &                                      &                                                \\
  \hline
  \hline
  \multirow{2}{*}{{AWGN}}                & \multirow{2}{*}{Yes}                 & \multirow{2}{*}{Additive White Gaussian Noise} \\
                                         &                                      &                                                \\
  \hline
  \multirow{2}{*}{{BEC}}                 & \multirow{2}{*}{No}                  & \multirow{2}{*}{Binary Erasure Channel}        \\
                                         &                                      &                                                \\
  \hline
  \multirow{2}{*}{{BSC}}                 & \multirow{2}{*}{No}                  & \multirow{2}{*}{Binary Symmetric Channel}      \\
                                         &                                      &                                                \\
  \hline
  \multirow{2}{*}{{Rayleigh}}            & \multirow{2}{*}{Yes}                 & \multirow{2}{*}{Flat Rayleigh fading channel}  \\
                                         &                                      &                                                \\
  \hline
  \multirow{2}{*}{{User defined}}        & \multirow{2}{*}{No}                  & User can import noise samples                  \\
                                         &                                      & from an external file                          \\
  \end{tabular}
\end{table}

For simulation purposes, it is crucial to emulate the behavior of the physical
layer. This is the role of the channel. There are many possible configurations
depending on the physics phenomena to simulate.
Table~\ref{tab:aff3ct_features_channels} reports all the supported channels. The
channels involve complex floating-point computations. It is frequent to use
expensive exponential and trigonometric operations. As for the decoders, the
channel software implementations have to be carefully optimized based on branch
instructions reduction and massive vectorization. The \emph{multi-user} column
refers to the ability of the channel to add correlated noise to a sub-set of
frames.

\section{Simulation of Digital Communication Algorithms}

\subsection{A Simulator Application on Top of the Library}
\label{sec:aff3ct_simulator_example}

The \AFFECT toolbox comes with a dedicated functional
simulator~\cite{Cassagne2017}. It is based on the \AFFECT library presented
before. We remarked that the functional simulation chains are often similar. For
this reason, the simulation chain presented in
Figure~\ref{fig:aff3ct_library_task_module} has been implemented and enriched.
The proposed simulator supports multi-threading to take advantage of current CPU
multi-core architectures. It is also able to run on supercomputers and comes
with a multi-node implementation based on the well-known HPC Message Passing
Interface (MPI). The multi-core and multi-node performance of the \AFFECT
simulator is illustrated later in Section~\ref{sec:eval_simu}.

One of the main advantage of the \AFFECT simulator is to come with a common
interface for many channel code families. It is also possible to evaluate the
error-rate performance of these code families on various configurations thanks
to the supported modems and channel models. This makes it easy to compare
different code families with each other.

\begin{listing}[htp]
  \inputminted[frame=lines]{bash}{\curChapter/src/use_cases/simulator/input.txt}
  \caption{Example of an \AFFECT simulator command.}
  \label{lst:aff3ct_simulator_input}
\end{listing}

The \AFFECT simulator is a command line executable. All its possible parameters
are exhaustively documented\footnote{\AFFECT documentation:
\url{https://aff3ct.readthedocs.io}}. Listing~\ref{lst:aff3ct_simulator_input}
proposes to simulate a $(2048,1723)$ polar code from 1 dB to 4 dB with a step of
1 dB (see Section~\ref{sec:ctx_simulation}). By default, the AWGN channel is
selected as well as the BPSK modulation. Then the SC decoder is specified. For a
given SNR, by default the simulation stops when more than 100 erroneous frames
have been detected.

\begin{listing}[htp]
  \inputminted[frame=lines,linenos]{console}{\curChapter/src/use_cases/simulator/output.txt}
  \caption{Example of an \AFFECT simulator output.}
  \label{lst:aff3ct_simulator_output}
\end{listing}

Listing~\ref{lst:aff3ct_simulator_output} shows the simulation results
corresponding to the \AFFECT command given in
Listing~\ref{lst:aff3ct_simulator_input} (note that some details have been
removed for concision). The same command line always gives the same decoding
performance results. \verb|FRA| stands for the number of simulated frames,
while \verb|BE| and \verb|FE| are the number of bit and frame errors.
The
simulator output is adapted to post processing: lines starting with a hashtag
can be skipped.

\subsection{In-depth Parameter Exploration}

One of the main strength of the \AFFECT simulator is to enable the exploration
of various configurations. In this section, a tour of possible experimentation
scenarios is given. The objective is not to be exhaustive and many more
parameters could be explored. However, it gives a representative overview of the
large variety of parameters that can be tweaked in the proposed simulator. As
shown in Section~\ref{sec:aff3ct_features}, many code families are supported. To
the best of our knowledge the \AFFECT toolbox regroups more channel codes than
all the other existing libraries (see Section~\ref{sec:aff3ct_related_works}).
Each of these codes can be simulated over many channel models (BEC, BSC, AWGN
and Rayleigh) and modulation schemes (PSK, QAM, PAM, OOK, CPM and SCMA). In this
thesis the channel model is always the AWGN and the modulation scheme is almost
always a BPSK. It can also be the SCMA modulation. It will be explicitly
mentioned in the latter case. For each channel code, many decoding algorithms
and their corresponding approximations can be compared.

\paragraph{Impact of the Decoder Algorithmic Parameters on the FER}

\begin{figure}[htp]
  \centering
  \includegraphics[width=0.7\textwidth]{\curChapter/fig/ldpc/update_rules/update_rules}
  \caption
    [Decoding performance of the LDPC BP algorithm depending on the update
     rules.]
    {Decoding performance of the LDPC BP algorithm depending on the update rules
     (horizontal layered scheduling). 40 iterations, IEEE 802.16e (WiMAX)
     $\mathcal{H}$ parity matrix ($N=2304$, $R=1/2$).}
  \label{plot:aff3ct_ldpc_update_rules}
\end{figure}

In Figure~\ref{plot:aff3ct_ldpc_update_rules}, the LDPC belief propagation (BP)
decoding algorithm is considered with an horizontal layered scheduling. The
$\mathcal{H}$ parity matrix has been taken from the WiMAX standard ($N=2304$,
$R=1/2$). The impact of various update rules on the decoding performance is
observed. As explained in Section~\ref{sec:ctx_ldpc}, the Min-Sum (MS) is an
approximation of the Sum-Product Algorithm (SPA) and leads to a performance
loss. The Offset Min-Sum (OMS) and the Normalized Min-Sum (NMS) are improvements
of the MS. They enable to recover a part of the SPA decoding performance.

\begin{figure}[htp]
  \centering
  \includegraphics[width=0.7\textwidth]{\curChapter/fig/ldpc/scheduling/scheduling}
  \caption
    [Decoding performance of the LDPC BP algorithm depending on the scheduling.]
    {Decoding performance of the LDPC BP algorithm depending on the scheduling
     techniques. Flooding (BP-F), horizontal layered (BP-HL) and vertical
     layered (BP-VL) scheduling are considered with SPA update rules. IEEE
     802.16e (WiMAX) $\mathcal{H}$ parity matrix ($N=2304$, $R=1/2$).}
  \label{plot:aff3ct_ldpc_scheduling}
\end{figure}

In Fig~\ref{plot:aff3ct_ldpc_scheduling} only the SPA is considered
and the decoding performances of various scheduling policies are compared. The
results show that the convergence of the layered scheduling policies is faster
than the traditional flooding scheduling for a same number of iterations.
Increasing the number of iterations improves the decoding performance while it
increases the computation complexity of the decoder. It is up to the system
designer to chose the right configuration.

\paragraph{Impact of the Decoder Type on the Throughput}

\begin{figure}[htp]
  \centering
  \includegraphics[width=0.70\textwidth]{\curChapter/fig/polar/scl_adaptive/scl_adaptive}
  \caption
    [FER and throughput of the polar fully and partially adaptive SSCL
     decoders.]
    {Frame Error Rate performance and throughput of the polar Fully and
     Partially Adaptive SSCL decoders (FA and PA). $N = 2048$, $K = 1723$ and
     32-bit CRC (GZip). Throughputs have been measured on the Intel\R Core\TM
     i5-6600K CPU.}
  \label{plot:aff3ct_polar_scl_adaptive}
\end{figure}

An example of polar decoders working on a $N = 2048$ and $K = 1723$ code is
given in Figure~\ref{plot:aff3ct_polar_scl_adaptive}. The FA-SSCL and PA-SSCL
decoders have the same decoding performance for a list size $L$. However,
the throughputs are different depending on the SNR values. This is another
example of possible explorations with the \AFFECT simulator. Depending on the
targeted SNR range, it is more interesting to choose either decoder.

\paragraph{Impact of the Decoder Quantization on the FER}

\begin{figure}[htp]
  \centering
  \includegraphics[width=0.7\textwidth]{\curChapter/fig/turbo/quantization/quantization}
  \caption
    [FER of the turbo decoder for $K = 6144$ (6 iterations) and
     $R=1/3$.]
    {Frame Error Rate of the turbo decoder for $K = 6144$, $R=1/3$ and 6
     decoding iterations. Enhanced max-log-MAP algorithm ($\alpha = 0.75$).}
  \label{plot:aff3ct_turbo_quantization}
\end{figure}

Another important feature is the impact of the quantization on the decoding
performance. To increase the throughput or to decrease the latency of a signal
processing, it is common to reduce the amplitude of the data. A fixed-point
representation can be shorter and more efficient than a floating-point
representation. This is true for hardware decoder implementations as well as for
high performance software implementations. In
Figure~\ref{plot:aff3ct_turbo_quantization}, the longest turbo code from the
LTE standard is proposed ($K = 6144$, $R = 1/3$). The same code is evaluated
over 3 different data representations. \emph{float} is a 32-bit decoder working
on floating-point data, this is the reference. \emph{int-16} and \emph{int-8}
decoders are working on 16 bits and on 8 bits, respectively. The $Q_{s,v}$
corresponds to the quantization format of the decoder input LLRs (see
Equation~\ref{eq:opt_simu_quantizer}). $s$ is the number of bits of the
quantized number, including $v$ bits for the fractional part. The quantization
format is a parameter of the \AFFECT simulator. In
Figure~\ref{plot:aff3ct_turbo_quantization}, the 16-bit quantization is able
to match the reference decoding performance while there is a little performance
degradation in 8-bit.

\paragraph{Effect of the SCMA Modulation Scheme on a Sub-set of Channel Codes}

\begin{figure}[htp]
  \centering
  \includegraphics[width=0.70\textwidth]{\curChapter/fig/scma/fec/fec_1_2}
  \caption
    [FER evaluation of the SCMA MPA and E-MPA demodulators.]
    {FER evaluation of the SCMA MPA and E-MPA demodulators combined with LDPC
     codes, polar codes and turbo codes ($K \approx 2048$ and $R \approx 1/2$).}
  \label{plot:aff3ct_scma_fec}
\end{figure}

More complex simulation scenarios where the BPSK modulation is replaced by the
SCMA modulation is illustrated in Figure~\ref{plot:aff3ct_scma_fec}. The MPA
demodulator and its E-MPA approximation are combined with the LDPC codes, the
polar codes and the turbo codes. The LDPC $\mathcal{H}$ parity matrix comes from
the MacKay personal webpage\footnote{MacKay's webpage:
\url{http://www.inference.org.uk/mackay/codes/data.html}}. The LDPC decoder used
is the BP-HL with the SPA update rules (100 iterations). The polar code is built
from the Gaussian Approximation technique. The polar decoder is the CA-SSCL
decoder with $L=32$ (the 32-bit GZIP CRC is used). The turbo code comes from the
LTE standard and it is punctured to support $R \approx 1/2$. The turbo decoder
is based on the EML-MAP with $\alpha = 0.75$ and 6 iterations. The purpose of
these curves is not to directly confront the three channel code families even if
we tried to select codes that have close enough characteristics. The results
show that the E-MPA approximation leads to a performance degradation for each
channel code family. But, this negative impact is higher for the selected LDPC
code than for other ones.

\subsection{BER/FER Comparator and Pre-simulated Results}

The \AFFECT output (see Listing~\ref{lst:aff3ct_simulator_output}) is not
adapted to see the error-rate performance at a glance. One can note that it is
even more complicated to compare two or more simulation outputs with each other.
Traditionally the BER and FER decoding performances are presented in a form of
graphical curves (see Figure~\ref{fig:ctx_bfer}). It is then much easier to
compare their decoding performance.

To this purpose, we introduced the BER/FER comparator. It is available online on
the \AFFECT website\footnote{\AFFECT online BER/FER comparator:
\url{http://aff3ct.github.io/comparator.html}}. It is capable of reading the
\AFFECT simulator outputs and it can also easily adapt to many other formats.
The comparator is written in JavaScript. This enables to run the comparator
easily on any web browser (no installation is needed). A database of \AFFECT
pre-simulated results is available. This database is the same as the error-rate
reference results used in the regression tests (see
Section~\ref{sec:aff3ct_ci_cd}). These references are classified according to
different characteristics: the code type, the modem type, the channel type,
the frame size ($N$) and the code rate ($R$). At the time of the writing,
approximatively 500 BER/FER references are available. For each reference, it
is possible to get the corresponding command line in the \AFFECT simulator. This
way, it is easy to reproduce the reference results or to modify the command line
parameters. The reference curves that have been published are marked with
the Digital Object Identifier (DOI) of the corresponding publication. It is then
possible to search a specific result from its DOI in the search bar. With the
online BER/FER comparator it is easy to share the selected curves with other
people thanks to a permalink (= an URL that contains the information of the
selected curves). The default proposed database is the \AFFECT database
(error-rate references). But it is also possible to access to the database of
the Kaiserslautern University\footnote{Kaiserslautern ML BER/FER database:
\url{https://www.uni-kl.de/channel-codes/ml-simulation-results/}}.

\subsection{Continuous Integration and Continuous Delivery}
\label{sec:aff3ct_ci_cd}

\AFFECT's development leverages a streamlined Continuous Integration (CI)
process. Each new commit the version control repository (Git) triggers a
comprehensive sequence of tests to catch potential regressions. These tests are
combined with Continuous Delivery (CD) tasks to deliver new \AFFECT builds
automatically.

\begin{figure}[htp]
  \centering
  \includegraphics[scale=1.0]{\curChapter/fig/ci_cd/pipeline/pipeline}
  \caption{\AFFECT continuous integration and continuous delivery pipeline.}
  \label{fig:aff3ct_ci_cd_pipeline}
\end{figure}

Figure~\ref{fig:aff3ct_library_task_module} shows the different stages of the
\AFFECT CI/CD pipeline. The \emph{analysis} stage contains jobs that can be
executed without compiling the \AFFECT binaries. The \emph{build} stage is a set
of compilation jobs. The \emph{check} stage proposes verification jobs that
require the \AFFECT binaries. The \emph{test} stage is composed by a set of jobs
focusing on regression testing. Error-rate reference results that have been
recorded from previous simulations are replayed. The \emph{coverage} stage
measures the percentage of the \AFFECT source code analyzed in the regression
tests. Finally, the \emph{deploy} stage contains jobs that are used to push the
pipeline results on various targets. For instance, the new builds are
automatically pushed on the \AFFECT website\footnote{\AFFECT download page:
\url{http://aff3ct.github.io/download.html}}.

\section{Impact and Community}
\label{sec:aff3ct_impact}

\AFFECT is currently used in several industrial contexts for simulation purposes
(Turbo concept, Airbus, Thales, Huawei) and for specific developments (CNES,
Schlumberger, Airbus, Thales, Orange, Safran), as well as in academic projects
(NAND French National Agency project, IdEx CPU, R\&T CNES). The MIT license
chosen for the project enables industrial and academic partners to reuse parts
of \AFFECT in their own projects without any restriction.

\AFFECT has been cited in scientific publications. Many works are exploiting the
\AFFECT simulator as a reference for the decoding performance~\cite{Pignoly2018,
Poulenard2018,Ghanaatian2018,Wang2019,Hsieh2020,Rush2020,Duffy2020}. In other
works, \AFFECT has been enriched to support new features.
In~\cite{Leonardon2018b} the P-EDGE generator tool (see
Section~\ref{sec:opt_polar_pedge}) has been modified to generate Transport
Triggered Architecture (TTA $\approx$ VLIW) instructions while
in~\cite{Tasdighi2020} a new LDPC code construction method is proposed and
directly implemented in the \AFFECT simulator. In some cases \AFFECT is used as
a library from which some sub-parts of the toolbox are reused or some
methodologies are extracted~\cite{Florian2018,Lemaitre2018,Cavatassi2019a,
Cavatassi2019b,Ercan2020}. A non-negligible part of the citations are
comparisons with the fast decoder implementations described in this
manuscript~\cite{Zeng2017,Leonardon2018a,Guermouche2019,LeGal2019a,Shen2020}.
Finally, in many works, \AFFECT is simply discussed and considered but not
directly used~\cite{Debbabi2016,Debbabi2016a,Ercan2017,Natarajan2018,Cenova2019,
Krainyk2019,Vameghestahbanati2019,Mohammed2019,Shaheen2019,Aly2019,
Delomier2020}.

As \AFFECT is open-source, some of the previous works have been integrated
inside the toolbox. However, it worths mentioning that \AFFECT is more often
simply used than enriched. We believe that its philosophy can lead to a growing
community of users and contributors. This is already demonstrated with the
increasing activity on the public issue tracker\footnote{\AFFECT issue tracker:
\url{https://github.com/aff3ct/aff3ct/issues}}.

\section{Conclusion}

In this chapter, \AFFECT, our open-source toolbox dedicated to digital
communication algorithms, is presented. First the focus is made on the library
with a software architecture that enables the algorithmic heterogeneity. Many
channel codes are supported like the LDPC codes, the polar codes, the turbo
codes, the TPC codes, the convolutional codes, the BCH codes, the RS codes, etc.
To the best of our knowledge, \AFFECT is the library with the most comprehensive
support for channel coding algorithms. \AFFECT also comes with multiple channel
models (AWGN, Rayleigh, BEC, BSC, etc.) and modulation schemes (PSK, QAM, PAM,
OOK, CPM, SCMA, etc.). All these efficient algorithm implementations can be
used from interfaces. Examples of library usages are given in native \Cxx or
by using the MATLAB\R wrapper. The \AFFECT toolbox has been valued in a
conference~\cite{Cassagne2017a} and a journal~\cite{Cassagne2019a}.

\AFFECT also comes with a BER/FER simulator. All the previously enumerated
features can be simulated over various parameters. The simulator takes advantage
of the CPUs multi-core architecture to reduce the restitution time. Its capacity
to explore a large variety of parameters is demonstrated. Many parameters can be
tweaked like the number of decoding iterations, the approximations in the
algorithm implementation, the quantization of the LLRs in the decoders, etc.
Some of these parameters are presented according to the decoders and
demodulators detailed in Chapter~\ref{chap:ctx} and Chapter~\ref{chap:opt}. Note
that this topic has been valued in a national conference~\cite{Cassagne2017}.

\AFFECT is designed to enable reproducible science. A BER/FER comparator tools
has been added to easily search in a database of 500 pre-simulated BER/FER
references. All there references are results simulated with \AFFECT and that can
be reproduced. To this purpose, a pipeline of tests has been implemented. Each
time there is a modification in the source code, the database of references is
replayed to avoid regressions. These tests are also ran on multiple
architectures (x86 and ARM\R) and operating systems (Windows, macOS and Linux)
to ensure that the portability is always conserved.

The last section discusses the \AFFECT impact in the community. It is shown that
more and more users are adopting the toolbox in both industrial and academic
contexts. The application contexts are varied and range from decoding
performance validations to the use of specific sub-parts of the library.
External contributions are still rare, however.

The next chapter proposes the performance evaluations of the decoder
implementations presented in Chapter~\ref{chap:opt} and packaged in \AFFECT.
The overall performance of the BER/FER simulator is also studied on various CPU
targets.
