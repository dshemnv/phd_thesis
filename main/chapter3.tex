%!TEX root = ../my_thesis.tex

\renewcommand{\curChapter}{main/chapter3}

\chapter{\AFFECT: A Fast Forward Error Correction Toolbox}
\label{chap:aff3ct}

This chapter is dedicated to the introduction of our \AFFECT open-source
toolbox. The first section describes the main prerequisites driven by four
objectives: high performance implementation, support for algorithmic
heterogeneity, portability and reproducible science.

In the second section, \AFFECT is compared with the other existing \verb|C|/\Cxx
FEC software libraries. The third section presents \AFFECT as a library
dedicated to the digital communication algorithms. The software architecture and
functionalities are described and examples of library use are given in \Cxx and
MATLAB. The fourth section focuses on the \AFFECT BER/FER simulator that comes
with the toolbox. A tour of the possible explorations is given and our BER/FER
comparator is presented. At the end, the \AFFECT testing strategy is explained.

The fifth section shows the impact of \AFFECT in industrial and academic
contexts. A review of the scientific publications that used \AFFECT is given.
The last section concludes this chapter.

\vspace*{\fill}
\minitoccustom
\vspace*{\fill}

\newpage
\section{Prerequisites}

\AFFECT for \emph{A Fast Forward Error Correction Toolbox} is a set of tools
regrouping all the contributions of this thesis and more.
% \AFFECT is pronounced \emph{[\textschwa'fekt]} like ``affect'' in English. The
% ``E'' is reversed to a ``3'' and symbolizes a channel error that can be easily
% corrected. It is also inspired by the leetspeak to create a proper noun.

\subsection{High Performance Implementations}

The signal processing community mainly writes source codes with high level
languages like MATLAB or Python. These languages allow to write implementations
close to the pseudo-code but an important part of the CPU computational power is
wasted. When targeting low error-rate functional simulations or real-time
constraints (like for the Cloud-RAN and the SDR), these high level languages are
not suitable. With the increasing complexity of the digital communication
systems it becomes crucial to have high performance implementations.

To this purpose, \AFFECT is mainly written in \Cxx~\cite{Stroustrup2013}. This
choice has been made to focus on high performance implementations without
sacrificing too much the expressibility. The \Cxx is a compiled language, it
allows very low level programming paradigms like intrinsics functions (or even
assembly code) as well as high level concepts like the Object-Oriented
Programming (OOP) paradigm. Moreover, the \Cxx comes with the template
meta-programming technique to facilitate the programming at compile time. An
other main advantage of the \Cxx is that it is constantly
evolving~\cite{Stroustrup2020} and it is well-spread in the HPC community.
However, we choose to limit the utilization of the \Cxx to its 2011 version
(\Cxy{11}). This choice has been made for two main reasons: 1) to maximize the
compatibility with the installed compilers in various environments; 2) the
\Cxy{11} features are sufficient for our utilization.

For the signal processing algorithms implemented in \AFFECT, we observed that
compared to interpreted languages, the speedups range from 10 to 1000 in \Cxx.
If we consider the very optimized implementations presented in
Chapter~\ref{chap:opt}, the speedups are closer to 1000. Of course the speedups
are not simply coming from the porting of the MATLAB code to the \Cxx code. It
is true that the compiler is sometime able to perform optimizations that will
benefit for the overall performance, but most of the speedup comes from
dedicated implementations. The \Cxx enables source code implementations to take
advantage of the hardware architecture. And, it is up to the developer to use
his/her knowledge of the CPU architecture in the development process. As
explained in Chapter~\ref{chap:opt}, optimizations like the vectorization, the
choice of an adapted data layout and the loop unrolling are the keys of the
proposed high performance implementations.

\subsection{Support for Algorithmic Heterogeneity}

As shown in Chapter~\ref{chap:ctx}~and~\ref{chap:opt}, there are many signal
processing algorithms along with many possible implementations. A summary list
of the algorithms supported by \AFFECT is given in the next section. It
motivates the need to regroup and package all these algorithms in a common
toolbox. The main interests are 1) to propose common and homogeneous interfaces
to the users and 2) to maximize code reuse among implementations.

In the context of the channel codes, the algorithmic heterogeneity is
challenging and each family has its own specificities. This is why in most
existing projects the focus is made on a single code family (see
Section~\ref{sec:aff3ct_related_works}). It strongly motivated the need of a
toolbox like \AFFECT. The objective is to homogenize the use of various code
families.

\MIPP is an example of code reuse as it defines elementary blocks used
everywhere in \AFFECT. Other macro blocks are also often reused like the
reordering process proposed in Sections~\ref{sec:opt_vec_inter}. There are many
other macro blocks in \AFFECT similar to the ones that are presented in the
manuscript. This allows to speedup and facilitate the implementation of new
efficient algorithms.

\subsection{Portability}

The portability is an other main concern in \AFFECT. The users from the signal
community use different operating systems. The predominant ones are Windows,
macOS and Linux. Thanks to the \Cxy{11} standard library, the same \AFFECT
source code can be compiled on these three systems. It is possible to compile
with the GNU compiler (GCC), the Clang compiler, the Intel\R \Cxx compiler
(ICPC) and the Microsoft\R Visual compiler (MSVC). Note that other operating
systems and compilers may also work as long as they are compatible with the
\Cxy{11} standard.

\AFFECT also takes advantage of various common CPU architectures like
Intel\R/AMD\R and ARM\R processors. The Intel\R/AMD\R CPUs are widely spread
in the current laptops as well as in the clusters (or in the supercomputers).
The ARM\R CPUs are interesting as they are generally consuming less energy than
the Intel\R/AMD\R CPUs: they are good candidates for embedded systems. Also,
they are more and more used in HPC contexts. At the time of the writing, Fugaku,
the most powerful supercomputer in the world, is based on ARM CPUs.

The heterogeneity of the CPU architectures is mainly managed by \MIPP (c.f.
Section~\ref{sec:opt_mipp}). The compiled binary is specialized to use the
appropriate SIMD ISA. If the architecture is not recognized then the \AFFECT
binary will fall-back to a sequential version.

\subsection{Reproducible Science}

In the signal processing community it is not common to share the resulting
implementations of a scientific publication. Thus, it is sometime a tedious task
to reproduce the state-of-the-art results and the community spends a
non-negligible amount of time in ``reinventing the wheel''. We think this should
be avoided and \AFFECT is an open source toolbox coming with a permissive MIT
license. This way, industrials and academics actors can invest themselves and
reuse parts of \AFFECT in their own projects without any restrictions. The
general impact of \AFFECT is discussed in Section~\ref{sec:aff3ct_impact}.

Even if the code is fully open, there is no guarantee that the achieved results
can be reproduced as the code is constantly evolving. Any modification of the
source code can break features that were working before. This problem is
inherent to all living projects. To reduce as much as possible the regressions,
a full pipeline of tests has been created and will be detailed in
Section~\ref{sec:aff3ct_ci_cd}. Each time someone makes a modification on the
\AFFECT source code, then the pipeline of tests is triggered. The
reproducibility of the results is based on the fact that for a given \AFFECT
simulator command line, the output BER/FER decoding performance should always be
the same. In other terms, the \AFFECT simulator is deterministic.

\section{Related Works}
\label{sec:aff3ct_related_works}

\begin{table}[htp]
  \centering
  \caption{\C/\Cxx open source channel coding simulators/libraries.}
  \label{tab:fec_libraries_comparison}
  % \begin{adjustbox}{angle=90}
  {\resizebox{\linewidth}{!}{
  \begin{tabular}{r   r  r  r  r  r | C{\simcolwidth}  C{\simcolwidth}  C{\simcolwidth}  C{\simcolwidth}  C{\simcolwidth}  C{\simcolwidth}  C{\simcolwidth}  C{\simcolwidth}  C{\simcolwidth}  C{\simcolwidth} }
  \multirow{4}{*}{\textbf{Name}} & \multirow{4}{*}{\textbf{Ref.}} &                  &                &                & \multirow{4}{*}{\textbf{License}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{Polar}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{LDPC}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{Turbo}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{Turbo P.}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{BCH}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{RS}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{Conv.}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{RA}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{Rep.}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{Erasure}} \\
                                 &                                & \textbf{Contri-} & \textbf{Code}  & \textbf{Start} &                                   &        &        &        &        &        &        &        &        &        &         \\ %\cline{5-6}
                                 &                                & \textbf{butors}  & \textbf{Lines} & \textbf{Year}  &                                   &        &        &        &        &        &        &        &        &        &         \\
                                 &                                &                  &                &                &                                   &        &        &        &        &        &        &        &        &        &         \\ \hline\hline
                                                                                                                                                           % Polar    LDPC     Turbo    TPC      BCH      RS       Conv.    RA       Rep.     Erasure
  {\AFFECT}                      & \cite{Cassagne2019a}           &               11 &            76k & 2016           & MIT                               & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \xmark  \\
  {aicodix GmbH}                 & \cite{Aicodix}                 &                1 &             7k & 2018           & Copyright                         & \xmark & \cmark & \xmark & \xmark & \cmark & \cmark & \xmark & \xmark & \xmark & \xmark  \\
  {eccpage}                      & \cite{ECCpage}                 &               20 &              - & 1989           & -                                 & \xmark & \cmark & \cmark & \xmark & \cmark & \cmark & \cmark & \xmark & \xmark & \cmark  \\
  {EZPWD}                        & \cite{EZPWDRS}                 &                2 &             6k & 2014           & GPLv3                             & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark  \\
  {FastECC}                      & \cite{FastECC}                 &                2 &             1k & 2015           & Apache 2.0                        & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark  \\
  {FEC-AL}                       & \cite{FEC-AL}                  &                1 &             3k & 2018           & BSD                               & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark & \xmark & \xmark & \cmark  \\
  {FECpp}                        & \cite{FECpp}                   &                1 &             2k & 2009           & -                                 & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark  \\
  {GNURadio}                     & \cite{GNURadio}                &              192 &           270k & 2006           & GPLv3                             & \cmark & \cmark & \xmark & \xmark & \xmark & \xmark & \cmark & \xmark & \cmark & \xmark  \\
  {Inan}                         & \cite{Inan-LDPC}               &                2 &            13k & 2018           & Copyright                         & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark  \\
  {IT++}                         & \cite{ITpp}                    &               20 &           109k & 2005           & GPLv3                             & \xmark & \cmark & \cmark & \xmark & \cmark & \cmark & \cmark & \xmark & \xmark & \xmark  \\
  {Le Gal}                       & \cite{LeGal-LDPC}              &                1 &            83k & 2015           & -                                 & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark  \\
  {Leopard}                      & \cite{Leopard}                 &                4 &             5k & 2017           & BSD                               & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark  \\
  {libcorrect}                   & \cite{Libcorrect}              &                6 &             5k & 2016           & BSD                               & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark & \cmark & \xmark & \xmark & \xmark  \\
  {Neal}                         & \cite{Neal-LDPC}               &                1 &             5k & 2006           & Copyright                         & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark  \\
  {OpenAir}                      & \cite{OpenAir}                 &              148 &           740k & 2013           & OAI Public                        & \xmark & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark  \\
  {OpenFEC}                      & \cite{OpenFEC}                 &                8 &            55k & 2009           & CeCCIL-C                          & \xmark & \cmark & \xmark & \xmark & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark  \\
  {Schifra}                      & \cite{Schifra}                 &                1 &             7k & 2010           & GPLv3                             & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark  \\
  {Siamese}                      & \cite{Siamese}                 &                1 &            11k & 2018           & BSD                               & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark & \xmark & \xmark & \cmark  \\
  {Tavildar (Polar)}             & \cite{Tavildar-Polar}          &                1 &             2k & 2016           & -                                 & \cmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark  \\
  {Tavildar (LDPC)}              & \cite{Tavildar-LDPC}           &                1 &             1k & 2016           & -                                 & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark  \\
  {the-art-of-ecc}               & \cite{The-art-of-ecc}          &                1 &              - & 2006           & Copyright                         & \xmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \xmark & \xmark & \xmark  \\
  {TurboFEC}                     & \cite{TurboFEC}                &                2 &             4k & 2015           & GPLv3                             & \xmark & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark  \\
  \end{tabular}
  }}
  % \end{adjustbox}
\end{table}

In the digital signal processing community, many scientists implement their own
simulation chain to validate their works.
Table~\ref{tab:fec_libraries_comparison} presents, to the best of our knowledge,
a list of currently available \verb|C|/\Cxx open source channel coding
simulators/libraries. This comparison table is also available
online where it is regularly updated\footnote{\texttt{C}/\Cxx Open Source FEC
Libraries: \url{http://aff3ct.github.io/fec_libraries.html}}. We choose to
compare with projects compiled as binaries, since they aim at high throughput
and low latency, as \AFFECT. Many open source projects in Python or in MATLAB
exist as well, but these tools are usually slower than compiled binaries, and
rather aim at prototyping.

Table~\ref{tab:fec_libraries_comparison} shows that, generally, the
\verb|C|/\Cxx FEC libraries target a single family or a small subset of channel
codes. As a consequence, a large effort is spent to re-develop similar features,
since all those libraries and tools share many characteristics (except the
channel code itself). \AFFECT attempts to lower this redundancy by offering a
full simulator/library that consistently supports a wide range of channel codes
and homogenizes usage (command line, \Cxx interfaces, etc.) across all code
families.

\section{Library of Digital Communication Algorithms}

\subsection{Software Architecture}
\label{sec:aff3ct_archi}

\AFFECT is developed in \Cxx in an object-oriented programming style. It
provides fundamental classes involved in the building of digital communication
chains. For instance, in Fig~\ref{fig:ctx_simu_com_chain}, the source, the
encoder, the modulator, the channel, the demodulator, the decoder and the
monitor are module classes. Tools can be classes or functions. For instance, the
polar API presented in Section~\ref{sec:opt_polar_api} is a static class
implementing the polar $f$, $g$ and $h$ functions (c.f.
Equation~\ref{eq:ctx_polar_f_g_h}) that are common to all the polar decoders.
Many implementations of defined interfaces can coexist. For instance, it exists
an abstract \verb|Encoder| class that defines the \verb|encode| pure virtual
method. The \verb|encode| method takes $\bm{u}$ bits of length $K$ as inputs and
outputs $\bm{c}$ bits of size $N$. Then, there are many implementations of the
\verb|Encoder| class like the \verb|Encoder_polar| class, the
\verb|Encoder_LDPC| class, the \verb|Encoder_turbo| class, etc. To simplify the
instanciation of the non-static classes (like the encoders), many factory
classes have been created (for the encoders but not only). Their job is to
simplify the allocation of the module and tool objects.

\subsubsection{Module}

All the classes that implement communication chain elements inherit from the
\verb|Module| abstract class. The particularity of the module classes is that
they have to expose at least one method that can be called in the context of
digital communication chains. These specific methods are called \emph{tasks}.
A task is an elementary processing performed on some data. For instance, the
\verb|Encoder| class inherits from the \verb|Module| class and defines the
\verb|encode| method which is a task. To be recognized as a task, the
\verb|encode| method has to be registered in the constructor of the
\verb|Encoder| class. The abstract \verb|Module| class defines and implements a
set of functions to perform this registering. Most of the time, when a developer
wants to add a new module, he does not need to register any task because it is
already done for him. For instance, if a developer wants to add a new encoder,
he simply needs to inherit from the proposed \verb|Encoder| class and to
implement the \verb|encode| method. A task is characterized by its
\emph{sockets}: they are used to describe the input and output data of the task
following a philosophy close to \emph{ports} in component-based development
approaches. The socket type can be input or output. The sockets also enable to
automatically allocate the data. In \AFFECT the convention is to automatically
allocate the data of the output sockets.

\subsubsection{Tools}

The tools regroups many different types of processing:
\begin{itemize}
  \item \textbf{Algorithmic \& Math}: the algorithmic components focus on the
    implementation of traditional algorithmic structures. For instance, it
    contains implementations of trees, matrices, histograms, etc. It also
    contains sorting and PRNG algorithms implementations. The math components
    regroup the interpolations, the Galois fields, the distributions, the
    integrations, etc.;
  \item \textbf{Channel code}: this type of tools regroups the processing
    implementations that are common to a single code family. For instance, the
    \verb|Polar_API| is located here;
  \item \textbf{Display}: these components are classes and functions dedicated
    to the display of the information in the terminal or in files. Statistic
    functions are located here as well as classed dedicated to the display of
    the BER and the FER performances;
  \item \textbf{Interface}: these abstract classes define interfaces. For
    instance, the \verb|Interface_reset| proposes a common interface for the
    \verb|reset| method. This way, all the classes inhering from this interface
    have exactly the same prototype for their implementation of the \verb|reset|
    method;
  \item \textbf{Performance}: this type of components is dedicated to high
    performance implementation. The vectorized reordering process presented in
    Section~\ref{sec:opt_vec_inter} is located here.
\end{itemize}
The above list is not exhaustive but is intended to give a representative
overview of what can be found in the tools.

\subsubsection{Factory}

In \AFFECT, one needs to allocate modules dynamically at the runtime. Combined
with the fact that there are many possible combinations of modules, we applied
the factory pattern. In the OOP paradigm, the factory method pattern is
dedicated to the the problem of creating objects without having to specify the
exact class of the object that will be created. This is done by calling a method
on the factory. In \AFFECT, all the factories propose a \verb|build| method to
this purpose. The return type of the \verb|build| method is always an abstract
class that regroups a sub-set of implemented classes. Considering the factory
\verb|Source| class, first the instantiation of this class is required. Then,
the created object comes with a list of public members that can be manually set
or deduced from the command line arguments. Once it is done the \verb|build|
method can be called. This method uses the public members (previously set) of
the object to instantiate an object of the module \verb|Source| class. This
object can be a \verb|Source_random| object, a \verb|Source_user_binary| object,
etc.

\subsection{Examples of Library Use}
\label{sec:aff3ct_library_example}

As a FEC library, \AFFECT can be used programmatically, for instance in
real-time contexts or to build specific functional simulations. \AFFECT blocks
can be used in external projects without restriction. In this section we propose
two illustrative examples of the \AFFECT library utilization. The first one is
dedicated to the simulation of a digital communication chain while the second
focuses on the validation of an hardware decoder.

\paragraph{Simulation of a Digital Communication Chain}

\begin{figure}[htp]
  \centering
  \includegraphics{\curChapter/fig/use_cases/library_task_module/library_task_module}
  \caption{Simulation of a digital communication chain using the \AFFECT
    library.}
  \label{fig:aff3ct_library_task_module}
\end{figure}
Figure~\ref{fig:aff3ct_library_task_module} shows the simulation chain we want
to implement. The represented modules an tasks correspond to the classes and
methods presented in the previous section. For instance, the \textit{modem}
module contains the \textit{modulate} and \textit{demodulate} tasks.
Figure~\ref{fig:aff3ct_library_task_module} presents common modules and tasks
typically found in a basic communication chain. It shows that the number of
tasks per module can vary depending on the module type.
\begin{listing}[htp]
  \inputminted[frame=lines,linenos]{C++}{\curChapter/src/use_cases/library/modules_allocation.cpp}
  \caption{Example of modules allocation with the \AFFECT library.}
  \label{lst:aff3ct_library_modules_allocation}
\end{listing}
The first step is to allocate the modules. In
Listing~\ref{lst:aff3ct_library_modules_allocation} we chose to allocate modules
on the stack, but it is also possible to do the same on the heap. $K$ is the
number of information bits, $N$ is the frame size and $E$ is the number of
erroneous frames to simulate. In this basic example, a repetition code is
selected, it simply repeats the information bits $N/K$ times.
\begin{listing}[htp]
  \inputminted[frame=lines,linenos]{C++}{\curChapter/src/use_cases/library/sockets_binding.cpp}
  \caption{Example of sockets binding with the \AFFECT library.}
  \label{lst:aff3ct_library_sockets_binding}
\end{listing}
The next step is to bind the sockets of successive tasks together (see
Listing~\ref{lst:aff3ct_library_sockets_binding}). To propose an easy to use
interface, sockets and tasks can be selected through the \verb|[]| operator,
which takes a \Cxx strongly typed enumerate. This way it is possible to
specialize the code depending on whether it is a socket or a task. Strongly
typed enumerates are checked at compile time (contrary to standard enumerates),
making it impossible to use wrong values. For instance, in the example, the
\textit{source} module output socket \verb|module::src::sck::generate::u| is
connected to the input socket \verb|module::enc::sck::encode::u| of the
\textit{encoder}.
\begin{listing}[htp]
  \inputminted[frame=lines,linenos]{C++}{\curChapter/src/use_cases/library/tasks_execution.cpp}
  \caption{Example of tasks execution with the \AFFECT library.}
  \label{lst:aff3ct_library_tasks_execution}
\end{listing}
The simulation is then started and each task is executed. In
Listing~\ref{lst:aff3ct_library_tasks_execution}, the whole communication chain
is executed multiple times, until the $E = 100$ frame error limit is achieved.
Complete examples of the \AFFECT library utilization are available on
GitHub\footnote{\AFFECT library examples: \url{https://github.com/aff3ct/my_project_with_aff3ct/}}.

\paragraph{Validation of an Hardware Decoder}

The \AFFECT library has also been used to prototype FPGA decoders.
In~\cite{Cassagne2017a}, a BCH decoder is implemented on a Xilinx\R Artix-7
FPGA. \AFFECT simulates the transmission of a first frame. The noisy frame is
then sent to the FPGA using the UART protocol. The hardware BCH decoder
processes the frame and sends it back to the PC. \AFFECT can then proceed and
perform the rest of the processing for this frame. Once the number of residual
errors is updated, \AFFECT starts with a new frame, and so on. The decoding
performance appears to be equivalent to the performance of the pure software
simulation which shows that the hardware BCH decoder is correctly implemented.

\subsection{MATLAB Wrapper}

In the signal processing community it is common to use MATLAB to implement and
to evaluate new algorithms or/and configurations. More specifically, the
\emph{Communications Toolbox} is often used. This toolbox contains a larger set
of digital communication algorithms than \AFFECT but they often lack of
efficiency, especially for the channel decoder implementations. Knowing that,
we developed a wrapper MATLAB to enable calls to the compiled \AFFECT library.
The wrapper can be seen as a new MATLAB toolbox that proposes faster decoder
implementations than the traditional MATLAB communications toolbox. \AFFECT
also comes with channel decoders that are not available in the standard
communications toolbox.

\begin{listing}[htp]
  \inputminted[frame=lines,linenos]{matlab}{\curChapter/src/use_cases/library/repetition_chain.m}
  \caption{Example of the \AFFECT MATLAB wrapper.}
  \label{lst:aff3ct_library_matlab}
\end{listing}

The proposed MATLAB wrapper is automatically generated for the \AFFECT headers.
The Clang compiler is used to generate the Abstract Syntax Tree (AST) of the
\AFFECT source code and a Python script extracts useful classes and methods.
These data are stored in a JSON database. Then, an other Python script as been
written to generate \Cxx and MATLAB codes that effectively perform the interface
between the \AFFECT library and MATLAB. Listing~\ref{lst:aff3ct_library_matlab}
shows the same example of code as in Section~\ref{sec:aff3ct_library_example}
written in MATLAB. At the time of the writing, the MATLAB wrapper has not been
publicly released yet.

\subsection{Software Functionalities}
\label{sec:aff3ct_features}

The \AFFECT software functionalities are decomposed in three main parts: the
\textit{codecs}, the \textit{modems} and the \textit{channels}.

\begin{table}[htp]
  \centering
  \caption{List of the channel codes (codecs) supported in \AFFECT.}
  \label{tab:aff3ct_features_codecs}
% {\footnotesize%\resizebox{\linewidth}{!}{
  \begin{tabular}{ c | c | c }
  \multirow{2}{*}{\textbf{Channel Code}}  & \multirow{2}{*}{\textbf{Standard}} & \multirow{2}{*}{\textbf{Decoders}}        \\
                                          &                                    &                                           \\
  \hline
  \hline
  \multirow{5}{*}{{LDPC}}                 & 5G (data), Wi-Fi,                  & Scheduling: Flooding and H./V. Layered    \\
                                          & WiMAX, WRAN,                       & Sum-Product Algorithm (SPA, log-SPA)      \\
                                          & 10 Gigabit Eth.,                   & Min-Sum its derivatives (MS, NMS and OMS) \\
                                          & DVB-S2, CCSDS                      & Approximate Min-Star (AMS)                \\
                                          & etc.                               & Bit Flipping: GallagerA/B/E, PPBF, WBF    \\
  \hline
                                          &                                    & Successive Cancellation (SC)              \\
  Polar                                   & 5G                                 & Successive Cancellation List (SCL)        \\
  (\Arikan mono-kernel)                   & (control channel)                  & CRC-Aided SCL (CA-SCL, FA-SCL, PA-SCL)    \\
                                          &                                    & Soft Cancellation (SCAN)                  \\
  \hline
  Polar                                   &                                    & Successive Cancellation (SC)              \\
  (mono/multi-kernel                      & --                                 & Successive Cancellation List (SCL)        \\
  generic)                                &                                    & CRC-Aided SCL (CA-SCL, PA-SCL)            \\

  \hline
  \multirow{1}{*}{{Turbo Parallel}}       & LTE (3G, 4G),                      & Turbo BCJR                                \\
  (single and double                      & DVB-RCS,                           & Turbo BCJR + Early Termination (CRC)      \\
  binary)                                 & CCSDS, etc.                        & Post proc.: Flip aNd Check (FNC)          \\
  \hline
  \multirow{2}{*}{{Turbo Product}}        & \multirow{2}{*}{WiMAX (opt.)}      & \multirow{2}{*}{Turbo Chase-Pyndiah}      \\
                                          &                                    &                                           \\
  \hline
  \multirow{3}{*}{{BCH}}                  & CD, DVD,                           &                                           \\
                                          & SSD, DVB-S2,                       & Berlekamp-Massey + Chien search           \\
                                          & Bitcoin, etc.                      &                                           \\
  \hline
  \multirow{3}{*}{{Reed-Solomon}}         & CD, DVD,                           &                                           \\
                                          & SSD, DVB-T,                        & Berlekamp-Massey + Chien search           \\
                                          & ADSL, etc.                         &                                           \\
  \hline
  \multirow{1}{*}{{Convolutional}}        &                                    & BCJR - Maximum A Posteriori (MAP)         \\
  (single and double                      & NASA                               & BCJR - Linear Approximation (L-MAP)       \\
  binary)                                 &                                    & BCJR - Max-log Approximation (ML-MAP)     \\
  \end{tabular}
% }%}
\end{table}

The codecs are the main part of the toolbox. There is a broad range of supported
codes listed in Table~\ref{tab:aff3ct_features_codecs}. They naturally encompass
the encoders and decoders, but they can also include puncturing patterns to
shorten frames length according to some communication standards. Most of the
codec algorithms come from the literature, while the others have been designed
under \AFFECT~\cite{Tonnellier2016a,Tonnellier2016b,Tonnellier2017,
Leonardon2019}. In channel coding, the decoder is the most time-consuming
process, compared to the puncturing and the encoding processes. This is why a
specific effort is put on ensuring the high computing performance of the
decoders. Most of the decoding algorithms have thus been optimized to satisfy
high throughput and low latency constraints~\cite{LeGal2015a,Cassagne2015c,
Cassagne2016a,Cassagne2016b}. Those optimizations generally involve a vectorized
implementation, a tailored data quantization and the use of fixed-point
arithmetic.

\begin{table}[htp]
  \centering
  \caption{List of the modulations/demodulations (modems) supported in \AFFECT.}
  \label{tab:aff3ct_features_modems}
  %{\footnotesize%\resizebox{\linewidth}{!}{
  \begin{tabular}{ c | c | c }
  \multirow{2}{*}{\textbf{Modem}} & \multirow{2}{*}{\textbf{Standard}} & \multirow{2}{*}{\textbf{Information}}  \\
                                  &                                    &                                        \\
  \hline
  \hline
  \multirow{3}{*}{{N-PSK}}        & IEEE 802.16 (WiMAX)                &                                        \\
                                  & UMTS (2G, 2G+)                     & Phase-Shift Keying                     \\
                                  & EDGE (8-PSK), ...                  &                                        \\
  \hline
  \multirow{3}{*}{{N-QAM}}        & IEEE 802.16 (WiMAX)                &                                        \\
                                  & UMTS (2G, 2G+)                     & Quadrature Amplitude Modulation        \\
                                  & 3G, 4G, 5G, ...                    &                                        \\
  \hline
  \multirow{3}{*}{{N-PAM}}        & IEEE 802.16 (WiMAX)                &                                        \\
                                  & UMTS (2G, 2G+)                     & Pulse Amplitude Modulation             \\
                                  & 3G, 4G, 5G, ...                    &                                        \\
  \hline
  \multirow{2}{*}{{CPM}}          & GMSK, Bluetooth                    & Continuous Phase Modulation            \\
                                  & IEEE 802.11 FHSS                   & Coded (convolutional-based) modulation \\
  \hline
  \multirow{2}{*}{{OOK}}          & IrDA (Infrared)                    & On-Off Keying                          \\
                                  & ISM bands                          & Used in optical communication systems  \\
  \hline
  \multirow{2}{*}{{SCMA}}         & \multirow{2}{*}{Considered for 5G} & Sparse Code Multiple Access            \\
                                  &                                    & Multi-user modulation                  \\
  \hline
  \multirow{2}{*}{{User defined}} & \multirow{2}{*}{-}                 & Constellation and order can be         \\
                                  &                                    & defined from an external file          \\
  \end{tabular}
  %}%}
\end{table}

In typical communication chains, it is necessary to adapt the digital signal
to the physical support. This operation is performed by the modulator and
conversely by the demodulator. \AFFECT comes with a rich set of modems to this
purpose. Table~\ref{tab:aff3ct_features_modems} lists all the supported modems.
\AFFECT supports several coded modulation/demodulation schemes like the
Continuous Phase Modulation (CPM)~\cite{Aulin1981a,Aulin1981b} and the Sparse
Code Multiple Access (SCMA) modulation~\cite{Nikopour2013,Ghaffari2017,
Ghaffari2019} (many codebooks are supported~\cite{AlteraSCMA,Wu2015,Cheng2015,
Zhang2016,Klimentyev2016,Song2017,Klimentyev2017}). It allows to easily combine
and evaluate the channel codes with several types of modulations. In the case of
the CPM, analogical wave shapes are also simulated. The other modulation schemes
are at the digital level.

\begin{table}[htp]
  \centering
  \caption{List of the channel models supported in \AFFECT.}
  \label{tab:aff3ct_features_channels}
  % {\footnotesize%\resizebox{\linewidth}{!}{
  \begin{tabular}{ c | c | c }
  \multirow{2}{*}{\textbf{Channel}}      & \multirow{2}{*}{\textbf{Multi-user}} & \multirow{2}{*}{\textbf{Information}}          \\
                                         &                                      &                                                \\
  \hline
  \hline
  \multirow{2}{*}{{AWGN}}                & \multirow{2}{*}{Yes}                 & \multirow{2}{*}{Additive White Gaussian Noise} \\
                                         &                                      &                                                \\
  \hline
  \multirow{2}{*}{{BEC}}                 & \multirow{2}{*}{No}                  & \multirow{2}{*}{Binary Erasure Channel}        \\
                                         &                                      &                                                \\
  \hline
  \multirow{2}{*}{{BSC}}                 & \multirow{2}{*}{No}                  & \multirow{2}{*}{Binary Symmetric Channel}      \\
                                         &                                      &                                                \\
  \hline
  \multirow{2}{*}{{Rayleigh}}            & \multirow{2}{*}{Yes}                 & \multirow{2}{*}{Flat Rayleigh fading channel}  \\
                                         &                                      &                                                \\
  \hline
  \multirow{2}{*}{{User defined}}        & \multirow{2}{*}{No}                  & User can import noise samples                  \\
                                         &                                      & from an external file                          \\
  \end{tabular}
  %}%}
\end{table}

For simulation purposes, it is crucial to emulate the behavior of the physical
layer. This is the role of the channel. There are many possible configurations
depending on the physics phenomena to simulate.
Table~\ref{tab:aff3ct_features_channels} reports all the supported channels. The
channels involve complex floating-point computations. It is frequent to use
expensive exponential and trigonometric operations. As for the decoders, the
channels have been carefully optimized based on branch instructions reduction
and massive vectorization.

\section{Simulation of Digital Communication Algorithms}

\subsection{A Simulator Application on Top of the Library}
\label{sec:aff3ct_simulator_example}

The \AFFECT toolbox comes with a dedicated functional
simulator~\cite{Cassagne2017}. It is based on the \AFFECT library presented
before. We remarked that the functional simulation chain used in the literature
are very often similar. For this reason, the simulation chain presented in
Fig.~\ref{fig:aff3ct_library_task_module} has been enriched and implemented. The
proposed simulator supports multi-threading to take advantage of the today CPUs
multi-core architecture. It is also able to run on supercomputers and comes with
a multi-node implementation based on the well-known HPC Message Passing
Interface (MPI). The multi-core and multi-node performance of the \AFFECT
simulator will be evaluated later in Section~\ref{sec:eval_simu}.

One of the main advantage of the \AFFECT simulator is to come with a common
interface for many channel code families. It is also possible to evaluate the
error-rate performance of these code families on various configurations thanks
to the supported modems and channel models. It also becomes easier to compare
different code families with each other.

\begin{listing}[htp]
  \inputminted[frame=lines]{bash}{\curChapter/src/use_cases/simulator/input.txt}
  \caption{Example of an \AFFECT simulator command.}
  \label{lst:aff3ct_simulator_input}
\end{listing}

The \AFFECT simulator is a command line executable and all its possible
parameters are exhaustively documented\footnote{\AFFECT documentation:
\url{https://aff3ct.readthedocs.io}}. Listing~\ref{lst:aff3ct_simulator_input}
proposes to simulate a $(2048,1723)$ polar code from 1 dB to 4 dB with a step of
1 dB (c.f. Section~\ref{sec:ctx_simulation}). By default, the AWGN channel is
selected as well as the BPSK modulation. Then the SC decoder is specified. For a
given SNR, by default the simulation stops when more than 100 erroneous frames
are detected.

\begin{listing}[htp]
  \inputminted[frame=lines,linenos]{console}{\curChapter/src/use_cases/simulator/output.txt}
  \caption{Example of an \AFFECT simulator output.}
  \label{lst:aff3ct_simulator_output}
\end{listing}

Listing~\ref{lst:aff3ct_simulator_output} shows the simulation results
corresponding to the \AFFECT command given in
Listing~\ref{lst:aff3ct_simulator_input} (note that some details have been
removed for concision). The same command line always gives the same decoding
performance results. \verb|FRA| stands for the number of simulated frames,
while \verb|BE| and \verb|FE| are the number of bit and frame errors. The
simulator output is adapted to post processing: lines starting with a hashtag
can be skipped.

\subsection{In-depth Parameter Exploration}

One of the main strength of the \AFFECT simulator is to enable the exploration
of various configurations. In this section, a tour of the possible parameters is
given. The objective is not to be exhaustive and many more parameters could be
explored. However, it gives a representative overview of the large variety of
parameters that can be tweaked in our proposed simulator. As shown in
Section~\ref{sec:aff3ct_features}, many code families are supported. To the best
of our knowledge the \AFFECT toolbox regroups more channel codes than all the
other existing libraries (see Section~\ref{sec:aff3ct_related_works}). Each of
these code can be simulated over many channel models (BEC, BSC, AWGN and
Rayleigh) and modulation schemes (PSK, QAM, PAM, OOK, CPM and SCMA). In this
thesis the channel model is always the AWGN and the modulation scheme is almost
always a BPSK. It can also be the SCMA modulation and it will be explicitly
mentioned in the latter case. For each channel code, many decoding algorithms
and their corresponding approximations can be compared.

\paragraph{Impact of the Decoder Algorithmic Parameters on the FER}

\begin{figure}[htp]
  \centering
  \includegraphics[width=0.7\textwidth]{\curChapter/fig/ldpc/update_rules/update_rules}
  \caption
    [Decoding performance of the LDPC BP algorithm depending on the update
     rules.]
    {Decoding performance of the LDPC BP algorithm depending on the update rules
     (horizontal layered scheduling). 40 iterations, IEEE 802.16e (WiMAX)
     $\mathcal{H}$ parity matrix ($N=2304$, $R=1/2$).}
  \label{plot:aff3ct_ldpc_update_rules}
\end{figure}

In Fig.~\ref{plot:aff3ct_ldpc_update_rules}, the LDPC belief propagation (BP)
algorithm is considered with an horizontal layered scheduling. The $\mathcal{H}$
parity matrix has been taken from the WiMAX standard ($N=2304$, $R=1/2$). The
impact of various update rules on the decoding performance is observed. As
explained in Section~\ref{sec:ctx_ldpc}, the Min-Sum (MS) is an approximation of
the Sum-Product Algorithm (SPA) and leads to a performance loss. The Offset
Min-Sum (OMS) and the Normalized Min-Sum (NMS) are improvements of the MS that
enable to recover a part of the SPA decoding performance.

\begin{figure}[htp]
  \centering
  \includegraphics[width=0.7\textwidth]{\curChapter/fig/ldpc/scheduling/scheduling}
  \caption
    [Decoding performance of the LDPC BP algorithm depending on the scheduling.]
    {Decoding performance of the LDPC BP algorithm depending on the scheduling
     policies. Flooding (BP-F), horizontal layered (BP-HL) and vertical layered
     (BP-VL) scheduling are considered (SPA update rules). IEEE 802.16e (WiMAX)
     $\mathcal{H}$ parity matrix ($N=2304$, $R=1/2$).}
  \label{plot:aff3ct_ldpc_scheduling}
\end{figure}

In Fig~\ref{plot:aff3ct_ldpc_scheduling} only the SPA is considered
and the decoding performance of various scheduling policies is compared. The
results show that the convergence of the layered scheduling policies is faster
than the traditional flooding scheduling for the same number of iterations.
Increasing the number of iterations improves the decoding performance while it
increases the computation complexity of the decoder. It is up to the system
designer to chose the right configuration.

\paragraph{Impact of the Decoder Type on the Throughput}

\begin{figure}[htp]
  \centering
  \includegraphics[width=0.70\textwidth]{\curChapter/fig/polar/scl_adaptive/scl_adaptive}
  \caption
    [FER and throughput of the polar fully and partially adaptive SSCL
     decoders.]
    {Frame Error Rate performance and throughput of the polar Fully and
     Partially Adaptive SSCL decoders (FA and PA). $N = 2048$, $K = 1723$ and
     32-bit CRC (GZip). Throughputs have been measured on the Intel\R Core\TM
     i5-6600K CPU.}
  \label{plot:aff3ct_polar_scl_adaptive}
\end{figure}

Fig.~\ref{plot:aff3ct_polar_scl_adaptive} is an example of polar decoders
working on a $N = 2048$ and $K = 1723$ code. The FA-SSCL and PA-SSCL decoders
have the same decoding performance for the same list size $L$. However, the
throughputs are different depending on the SNR zone. This is an other example of
possible exploration with the \AFFECT simulator. Depending on the targeted SNR
range, it is more interesting to choose either decoder.

\paragraph{Impact of the Decoder Quantification on the FER}

\begin{figure}[htp]
  \centering
  \includegraphics[width=0.7\textwidth]{\curChapter/fig/turbo/quantification/quantification}
  \caption
    [FER of the turbo decoder for $K = 6144$ (6 iterations) and
     $R=1/3$.]
    {Frame Error Rate of the turbo decoder for $K = 6144$, $R=1/3$ and 6
     decoding iterations. Enhanced max-log-MAP algorithm ($\alpha = 0.75$).}
  \label{plot:aff3ct_turbo_quantification}
\end{figure}

An other important aspect to observe is the impact of the quantification on the
decoding performance. To increase the throughput or to decrease the latency of
a signal processing, it is common to reduce the amplitude of the data and to
use a fixed-point representation that can be shorter and more efficient than a
floating-point representation. This is true for hardware decoders as well as for
high performance software implementations. In
Fig.~\ref{plot:aff3ct_turbo_quantification}, the biggest turbo code from the LTE
standard is proposed ($K = 6144$, $R = 1/3$). The same code is evaluated over 3
different data representations. \emph{float} is a 32-bit decoder working on
floating-point data, this is the reference. \emph{int-16} and \emph{int-8}
decoders are working on fixed-point data, respectively on 16 bits and on 8 bits.
The $Q_{s,v}$ corresponds to the quantification format of the decoder input LLRs
(c.f. Eq.~\ref{eq:opt_simu_quantizer}). $s$ is the number of bits of the
quantized number, including $v$ bits for the fractional part. The quantification
format is a parameter of the \AFFECT simulator. In
Fig.~\ref{plot:aff3ct_turbo_quantification}, the 16-bit quantification is able
to match the reference decoding performance while there is a little performance
degradation in 8-bit.

\paragraph{Effect of the SCMA Modulation Scheme on a Sub-set of Channel Codes}

\begin{figure}[htp]
  \centering
  \includegraphics[width=0.70\textwidth]{\curChapter/fig/scma/fec/fec_1_2}
  \caption
    [FER evaluation of the SCMA MPA and E-MPA demodulators.]
    {FER evaluation of the SCMA MPA and E-MPA demodulators combined with LDPC,
     polar and turbo codes ($K \approx 2048$ and $R \approx 1/2$).
     The LDPC $\mathcal{H}$ parity matrix comes from the MacKay personal
     webpage\footnote{MacKay's webpage: \url{http://www.inference.org.uk/mackay/codes/data.html}}.
     The LDPC decoder used is the BP-HL with the SPA update rules (100
     iterations). The polar code is built from the Gaussian Approximation
     technique. The polar decoder is the CA-SSCL decoder with $L=32$ (the 32-bit
     GZIP CRC is used). The turbo code comes from the LTE standard and it is
     punctured to support $R \approx 1/2$. The turbo decoder is the EML-MAP with
     $\alpha = 0.75$ and 6 iterations.}
  \label{plot:aff3ct_scma_fec}
\end{figure}

Fig.~\ref{plot:aff3ct_scma_fec} demonstrates complex simulation scenarios where
the BPSK modulation is replaced by the SCMA modulation. The MPA demodulator and
its E-MPA approximation are combined with the LDPC, the polar and the turbo
codes. The purpose of these curves is not to directly confront the 3 channel
code families even if we tried to select codes that have close enough
characteristics. The results show that the E-MPA approximation leads to a
performance degradation for each channel code family but this negative impact is
higher for the selected LDPC code than for the selected polar and turbo codes.

\subsection{BER/FER Comparator and Pre-simulated Results}

The \AFFECT output (see Listing~\ref{lst:aff3ct_simulator_output}) is not
adapted to see the error-rate performance at a glance. And it is even more
complicated to compare two or more simulation outputs with each other.
Traditionally the BER and FER decoding performances are presented in a form of
graphical curves (see Fig.~\ref{fig:ctx_bfer}). It is then much easier to
compare their decoding performance.

To this purpose, the BER/FER comparator is introduced. It is available
online on the \AFFECT website\footnote{\AFFECT online BER/FER comparator:
\url{http://aff3ct.github.io/comparator.html}}. It is capable to read the
\AFFECT simulator outputs but it can also easily adapt to many other formats.
The comparator is written in JavaScript. This allows to run the comparator
easily on on any web browser (no installation is needed). A database of \AFFECT
pre-simulated results is available. This database is the same as the error-rate
reference results used in the regression tests (c.f.
Section~\ref{sec:aff3ct_ci_cd}). These references are classified according to
different characteristics: the code type, the modem type, the channel type,
the frame size ($N$) and the code rate ($R$). At the time of the writing,
approximatively 500 BER/FER references are available. For each reference, it
possible to get the corresponding command line in the \AFFECT simulator. This
way it is easy to reproduce the reference results or to modify the command line
parameters. The reference curves that have been published are marked with
the Digital Object Identifier (DOI) of the publication they appear in. It is
then possible to search a specific result from its DOI in the search bar. With
the online BER/FER comparator it is easy to share the selected curves with other
people thanks to a permalink (= an URL that contains the information of the
selected curves). The default proposed database is the \AFFECT database
(error-rate references) but it is also possible to enable the database of the
Kaiserslautern University\footnote{Kaiserslautern ML BER/FER database:
\url{https://www.uni-kl.de/channel-codes/ml-simulation-results/}}.

\subsection{Continuous Integration and Continuous Delivery}
\label{sec:aff3ct_ci_cd}

\AFFECT's development leverages streamlined Continuous Integration (CI) process.
Each new commit the version control repository (Git) triggers a comprehensive
sequence of tests to catch potential regressions. These tests are combined with
Continuous Delivery (CD) tasks to deliver new \AFFECT builds automatically.

\begin{figure}[htp]
  \centering
  \includegraphics[scale=1.0]{\curChapter/fig/ci_cd/pipeline/pipeline}
  \caption{\AFFECT continuous integration and continuous delivery pipeline.}
  \label{fig:aff3ct_ci_cd_pipeline}
\end{figure}

Fig.~\ref{fig:aff3ct_library_task_module} shows the different stages of the
\AFFECT CI/CD pipeline. The \emph{analysis} stage contains jobs that can be
executed without compiling the \AFFECT binaries. The \emph{build} stage is a set
of compilation jobs. The \emph{check} stage proposes verification jobs that
require the \AFFECT binaries. The \emph{test} stage is composed by a set of jobs
focusing on regression testing: error-rate reference results that have been
recorded from previous simulations are replayed. The \emph{coverage} stage
measures the percentage of the \AFFECT source code used in the regression tests.
Finally, the \emph{Deploy} stage contains jobs that are used to push the
pipeline results on various targets. For instance, the new builds are
automatically pushed on the \AFFECT website\footnote{\AFFECT download page:
\url{http://aff3ct.github.io/download.html}}.

\section{Impact and Community}
\label{sec:aff3ct_impact}

\AFFECT is currently used in several industrial contexts for simulation purposes
(Turbo concept, Airbus, Thales, Huawei) and for specific developments (CNES,
Schlumberger, Airbus, Thales, Orange), as well as in academic projects (NAND
French National Agency project, IdEx CPU). The MIT license used in the project
enables industrial and academic partners to reuse parts of \AFFECT in their own
projects without any restriction.

\AFFECT has been cited in scientific publications. Many works are using the
\AFFECT simulator as a reference for the decoding performance~\cite{Pignoly2018,
Poulenard2018,Ghanaatian2018,Wang2019,Hsieh2020,Rush2020,Duffy2020}. In other
works, \AFFECT has been enriched to support new features:
in~\cite{Leonardon2018b} the P-EDGE generator tool (c.f.
Section~\ref{sec:opt_polar_pedge}) has been modified to generate Transport
Triggered Architecture (TTA $\approx$ VLIW) instructions while
in~\cite{Tasdighi2020} a new LDPC code construction method is proposed and
directly implemented in the \AFFECT simulator. In some cases \AFFECT is used as
a library where some sub-parts of the toolbox are reused or some methodologies
are extracted~\cite{Florian2018,Cavatassi2019a,Cavatassi2019b,Ercan2020}. A
non-negligible part of the citations are comparisons with the fast decoder
implementations described in this manuscript~\cite{Zeng2017,Leonardon2018a,
Guermouche2019,LeGal2019a,Shen2020}. Finally, in many works, \AFFECT is simply
discussed and considered but not directly used~\cite{Debbabi2016,Debbabi2016a,
Ercan2017,Natarajan2018,Cenova2019,Krainyk2019,Vameghestahbanati2019,
Mohammed2019,Shaheen2019,Aly2019,Delomier2020}.

As \AFFECT is open-source, some of the previous works have been integrated
inside the toolbox. However, it worths mentioning that \AFFECT is more often
simply used than enriched. We believe that its philosophy can lead to a growing
community of users and contributors. This is already demonstrated with the
increasing activity on the public issue tracker\footnote{\AFFECT issue tracker:
\url{https://github.com/aff3ct/aff3ct/issues}}.

\section{Conclusion}

In this chapter, \AFFECT, our open-source toolbox dedicated to digital
communication algorithms, is presented. First the focus is made on the library
with a software architecture that enables the algorithmic heterogeneity. Many
channel codes are supported like the LDPC codes, the polar codes, the turbo
codes, the TPC codes, the convolutional codes, the BCH codes, the RS codes, etc.
To the best of our knowledge, \AFFECT is the library with the most comprehensive
support for channel coding algorithms. \AFFECT also comes with multiple channel
models (AWGN, Rayleigh, BEC, BSC, etc.) and modulation schemes (PSK, QAM, PAM,
OOK, CPM, SCMA, etc.). All these efficient algorithm implementations can be
used from interfaces and examples of library usages are given in native \Cxx or
by using the MATLAB wrapper.

\AFFECT also comes with a BER/FER simulator. All the previously enumerated
features can be simulated over various parameters. The simulator takes advantage
of the CPUs multi-core architecture to reduce the restitution time. Its capacity
to explore a large variety of parameters is demonstrated. Many parameters can be
tweaked like the number of decoding iterations, the approximations in the
algorithm implementation, the quantification of the LLRs in the decoders, etc.
Some of these parameters are presented according to the decoders and
demodulators introduced in Chapter~\ref{chap:ctx} and Chapter~\ref{chap:opt}.

\AFFECT is designed to enable reproducible science. A BER/FER comparator tools
has been developed to easily search in a database of 500 pre-simulated BER/FER
references. All there references are results simulated with \AFFECT and that can
be reproduced. To this purpose, a pipeline of tests has been implemented: each
time there is a modification in the source code, the database of references is
replayed to avoid regressions. These tests are also ran on multiple
architectures (x86 and ARM\R) and operating systems (Windows, macOS and Linux)
to ensure that the portability is always conserved.

The last section discusses the \AFFECT impact in the community. It is shown that
more and more users are adopting the toolbox in both industrial and academic
contexts. The application contexts are varied and range from decoding
performance validations to the use of specific sub-parts of the library.
External contributions are still rare, however.
