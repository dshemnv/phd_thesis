%!TEX root = ../my_thesis.tex

\renewcommand{\curChapter}{main/chapter3}

\chapter{\AFFECT: A Fast Forward Error Correction Toolbox}
\label{chap:aff3ct}

This chapter is dedicated to our \AFFECT open-source toolbox. The first section
gives the main philosophy driven by four strong objectives: high performance
implementations, algorithmic heterogeneity, portability and reproducible
science. Then, in the second section, \AFFECT is compared with the other
existing \verb|C|/\Cxx FEC software libraries.

The third section presents \AFFECT as a library dedicated to the digital
communication algorithms. The software architecture and functionalities are
described and examples of library use are given in \Cxx and MATLAB.

The fourth section focuses on the \AFFECT BER/FER simulator that comes with
the toolbox. A tour of the possible explorations is given and our BER/FER
comparator is presented. At the end, the \AFFECT testing strategy is explained.

The fifth section shows the impact of \AFFECT in industrial and academic
contexts. A review of the scientific publications that used \AFFECT is given.

The last section concludes this chapter.

\vspace*{\fill}
\minitoccustom
\vspace*{\fill}

\newpage
\section{Philosophy}

\AFFECT for \emph{A Fast Forward Error Correction Toolbox} is a set of tools
regrouping all the contributions of this thesis and more. \AFFECT is pronounced
\emph{\textschwa'fekt} like ``affect'' in English. The ``E'' is reversed to a
``3'' and symbolizes a channel error that can be easily corrected. It is also
inspired by the leetspeak to create a proper noun.

\subsection{High Performance Implementations}

\AFFECT is mainly written in \Cxx~\cite{Stroustrup2013}. This choice has been
made to focus on high performance implementations without sacrificing too much
the expressibility. The \Cxx is a compiled language, it allows very low level
programming paradigms like intrinsics functions (or even assembly code) as well
as high level concepts like the Object-Oriented Programming (OOP) paradigm.
Moreover, the \Cxx comes with the template meta-programming technique to
facilitate the programming at compile time. An other main advantage of the \Cxx
is that it is constantly evolving~\cite{Stroustrup2020} and it is well-spread in
the HPC community. We choose to limit the utilization of the \Cxx to its 2011
version (\Cxy{11}). This choice has been made for two main reasons: 1) to
maximize the compatibility with the installed compilers in various environments;
2) the \Cxy{11} features are now largely adopted by the developers community
while the need of the new \Cxx standards is still sometimes questioned.

The signal processing community mainly writes source codes with high level
languages like MATLAB or Python. There is no doubt that these language allows
to write implementations close to the pseudo-code but an important part of the
CPU computational power is wasted. When targeting low error-rate functional
simulations or real-time constraints (like for the Cloud-RAN and the SDR), these
high level languages are not suitable. For the signal processing algorithms
implemented in \AFFECT, we observed that compared to interpreted languages, the
speedups range from 10 to 1000 in \Cxx. And, if we consider the very optimized
implementations presented in Chapter~\ref{chap:opt}, the speedups are closer to
1000.

Of course the speedups are not simply coming from the porting of the MATLAB
code to the \Cxx code. It is true that the compiler is sometime able to perform
optimizations that will benefit for the overall performance, but most of the
speedup comes from dedicated implementations. The \Cxx enables source code
implementations to take advantage of the hardware architecture. And, it is up
to the developer to use its knowledge of the CPU architecture in the development
process. As explained in Chapter~\ref{chap:opt}, optimizations like the
vectorization, the choice of an adapted data layout and the loop unrolling are
the keys of the proposed high performance implementations.

\subsection{Algorithmic Heterogeneity}

As shown in Chapter~\ref{chap:ctx}~and~\ref{chap:opt}, there are many signal
processing algorithms along with many possible implementations. A summary list
of the algorithms supported by \AFFECT will be given in the next section. Thus,
it motivates the need to regroup and package all these algorithms in a common
toolbox. The main interests are 1) to propose common and homogeneous interfaces
to the users and 2) to maximize the code reuse in the implementations.

\MIPP is a perfect example of code reuse as it defines elementary blocks used
everywhere in \AFFECT. But other macro blocks are also often reused like the
reordering process proposed in Sections~\ref{sec:opt_vec_inter}. Of course there
are many other macro blocks in \AFFECT similar to the ones that are presented in
the manuscript. This allows to speedup and facilitate the implementation of new
efficient algorithms.

In the context of the channel codes, the algorithmic heterogeneity is
challenging and each family has its own specificities. This is the main reason
why in most of the other existing projects the focus is made on a single code
family (c.f. Section~\ref{sec:aff3ct_related_works}). It strongly motivated
the need of a toolbox like \AFFECT. The objective is to homogenize the use of
various code families. The \AFFECT source code organization is detailed in
Section~\ref{sec:aff3ct_archi}.

\subsection{Portability}

The portability is an other main concern in \AFFECT. Thanks to the \Cxy{11}
standard library, the same \AFFECT source code can be compiled on Windows, macOS
and Linux. It is possible to compile with the GNU compiler (GCC), the Clang
compiler, the Intel\R \Cxx compiler (ICPC) and the Microsoft\R Visual compiler
(MSVC). Note that other operating systems and compilers may also work as long as
they are compatible with the \Cxy{11} standard.

\AFFECT can also take advantage of various common CPU architectures like
Intel\R/AMD\R and ARM\R processors. Thanks to \MIPP (c.f.
Section~\ref{sec:opt_mipp}), the compiled binary is specialized to use the
appropriate SIMD ISA. If the architecture is not recognized then the \AFFECT
binary will fall-back to a sequential version.

The portability is the key to enable the utilization of \AFFECT in various
contexts.
% We identified some possible use cases: they are presented in
%Section~\ref{sec:aff3ct_use_cases}.

\subsection{Reproducible Science}

In the signal processing community it is not common to share the resulting
implementations of a scientific publication. Thus, it is sometime a tedious task
to reproduce the state-of-the-art results and the community spends a
non-negligible amount of time in ``reinventing the wheel''. We think this should
be avoided and \AFFECT is an open source toolbox coming with a permissive MIT
license. This way, industrials and academics actors can invest themselves and
reuse parts of \AFFECT in their own projects without any restrictions. The
general impact of \AFFECT is discussed in Section~\ref{sec:aff3ct_impact}.

Even if the code is fully open, there is no guarantee that the achieved results
can be reproduced as the code is constantly evolving. Any modification of the
source code can break features that were working before. This problem is
inherent to all living projects. To reduce as much as possible the regressions,
a full pipeline of tests has been created and will be detailed in
Section~\ref{sec:aff3ct_ci_cd}. Each time someone makes a modification on the
\AFFECT source code, then the pipeline of tests is triggered.

\section{Related Works}
\label{sec:aff3ct_related_works}

\begin{table}[htp]
  \centering
  \caption{\C/\Cxx open source channel coding simulators/libraries.}
  \label{tab:fec_libraries_comparison}
  % \begin{adjustbox}{angle=90}
  {\resizebox{\linewidth}{!}{
  \begin{tabular}{r   r  r  r  r  r | C{\simcolwidth}  C{\simcolwidth}  C{\simcolwidth}  C{\simcolwidth}  C{\simcolwidth}  C{\simcolwidth}  C{\simcolwidth}  C{\simcolwidth}  C{\simcolwidth}  C{\simcolwidth} }
  \multirow{4}{*}{\textbf{Name}} & \multirow{4}{*}{\textbf{Ref.}} &                  &                &                & \multirow{4}{*}{\textbf{License}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{Polar}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{LDPC}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{Turbo}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{Turbo P.}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{BCH}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{RS}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{Conv.}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{RA}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{Rep.}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{Erasure}} \\
                                 &                                & \textbf{Contri-} & \textbf{Code}  & \textbf{Start} &                                   &        &        &        &        &        &        &        &        &        &         \\ %\cline{5-6}
                                 &                                & \textbf{butors}  & \textbf{Lines} & \textbf{Year}  &                                   &        &        &        &        &        &        &        &        &        &         \\
                                 &                                &                  &                &                &                                   &        &        &        &        &        &        &        &        &        &         \\ \hline\hline
                                                                                                                                                           % Polar    LDPC     Turbo    TPC      BCH      RS       Conv.    RA       Rep.     Erasure
  {\AFFECT}                      & \cite{Cassagne2019a}           &               11 &            76k & 2016           & MIT                               & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \xmark  \\
  {aicodix GmbH}                 & \cite{Aicodix}                 &                1 &             7k & 2018           & Copyright                         & \xmark & \cmark & \xmark & \xmark & \cmark & \cmark & \xmark & \xmark & \xmark & \xmark  \\
  {eccpage}                      & \cite{ECCpage}                 &               20 &              - & 1989           & -                                 & \xmark & \cmark & \cmark & \xmark & \cmark & \cmark & \cmark & \xmark & \xmark & \cmark  \\
  {EZPWD}                        & \cite{EZPWDRS}                 &                2 &             6k & 2014           & GPLv3                             & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark  \\
  {FastECC}                      & \cite{FastECC}                 &                2 &             1k & 2015           & Apache 2.0                        & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark  \\
  {FEC-AL}                       & \cite{FEC-AL}                  &                1 &             3k & 2018           & BSD                               & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark & \xmark & \xmark & \cmark  \\
  {FECpp}                        & \cite{FECpp}                   &                1 &             2k & 2009           & -                                 & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark  \\
  {GNURadio}                     & \cite{GNURadio}                &              192 &           270k & 2006           & GPLv3                             & \cmark & \cmark & \xmark & \xmark & \xmark & \xmark & \cmark & \xmark & \cmark & \xmark  \\
  {Inan}                         & \cite{Inan-LDPC}               &                2 &            13k & 2018           & Copyright                         & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark  \\
  {IT++}                         & \cite{ITpp}                    &               20 &           109k & 2005           & GPLv3                             & \xmark & \cmark & \cmark & \xmark & \cmark & \cmark & \cmark & \xmark & \xmark & \xmark  \\
  {Le Gal}                       & \cite{LeGal-LDPC}              &                1 &            83k & 2015           & -                                 & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark  \\
  {Leopard}                      & \cite{Leopard}                 &                4 &             5k & 2017           & BSD                               & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark  \\
  {libcorrect}                   & \cite{Libcorrect}              &                6 &             5k & 2016           & BSD                               & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark & \cmark & \xmark & \xmark & \xmark  \\
  {Neal}                         & \cite{Neal-LDPC}               &                1 &             5k & 2006           & Copyright                         & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark  \\
  {OpenAir}                      & \cite{OpenAir}                 &              148 &           740k & 2013           & OAI Public                        & \xmark & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark  \\
  {OpenFEC}                      & \cite{OpenFEC}                 &                8 &            55k & 2009           & CeCCIL-C                          & \xmark & \cmark & \xmark & \xmark & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark  \\
  {Schifra}                      & \cite{Schifra}                 &                1 &             7k & 2010           & GPLv3                             & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark  \\
  {Siamese}                      & \cite{Siamese}                 &                1 &            11k & 2018           & BSD                               & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark & \xmark & \xmark & \cmark  \\
  {Tavildar (Polar)}             & \cite{Tavildar-Polar}          &                1 &             2k & 2016           & -                                 & \cmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark  \\
  {Tavildar (LDPC)}              & \cite{Tavildar-LDPC}           &                1 &             1k & 2016           & -                                 & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark  \\
  {the-art-of-ecc}               & \cite{The-art-of-ecc}          &                1 &              - & 2006           & Copyright                         & \xmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \xmark & \xmark & \xmark  \\
  {TurboFEC}                     & \cite{TurboFEC}                &                2 &             4k & 2015           & GPLv3                             & \xmark & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark  \\
  \end{tabular}
  }}
  % \end{adjustbox}
\end{table}

In the digital signal processing community, many scientists implement their own
simulation chain to validate their works.
Table~\ref{tab:fec_libraries_comparison} presents, to the best of our knowledge,
a list of currently available \verb|C|/\Cxx open source channel coding
simulators/libraries. This comparison table is also available
online where it is regularly updated\footnote{\texttt{C}/\Cxx Open Source FEC
Libraries: \url{http://aff3ct.github.io/fec_libraries.html}}. We choose to
compare with projects compiled as binaries, since they aim at high throughput
and low latency, as \AFFECT. Many open source projects in Python or in MATLAB
exist as well, but these tools are usually slower than compiled binaries, and
rather aim at prototyping.

Table~\ref{tab:fec_libraries_comparison} shows that, generally, the
\verb|C|/\Cxx FEC libraries target a single family or a small subset of channel
codes. As a consequence, a large effort is spent to re-develop similar features,
since all those libraries and tools share many characteristics (except the
channel code itself). \AFFECT attempts to lower this redundancy by releasing a
full simulator/library that consistently supports a wide range of channel codes
to the community. \AFFECT also tries to homogenize usage (command line, \Cxx
interfaces, etc.) for all code families.

Note that Table~\ref{tab:fec_libraries_comparison} does not aim at comparing
channel code implementation performances. The implementations of the decoders
will be compared in Chapter~\ref{chap:eval}.

\section{Library of Digital Communication Algorithms}

\subsection{Software Architecture}
\label{sec:aff3ct_archi}

\AFFECT is developed in \Cxx in an object-oriented programming style. It
provides fundamental classes involved in the building of digital communication
chains. These classes are regrouped in the \verb|aff3ct::module| namespace. For
instance, in Fig~\ref{fig:ctx_simu_com_chain}, the source, the encoder, the
modulator, the channel, the demodulator, the decoder and the monitor are module
classes. This type of classes can use sub-blocks that can be common to more than
one module, this sub-blocks are regrouped in the \verb|tools::module| namespace.
The tools can be classes or functions. For instance, the polar API presented in
Section~\ref{sec:opt_polar_api} is a static class implementing the polar $f$,
$g$ and $h$ functions (c.f. Equation~\ref{eq:ctx_polar_f_g_h}) that are common
to all the polar decoders. Thus, the \verb|Polar_API| class is in the
\verb|tools::tools| namespace. As we are in an OOP paradigm, it can exist many
implementations of defined interfaces. For instance, it exists an abstract
\verb|Encoder| class that defines the \verb|encode| pure virtual method. The
\verb|encode| method takes $\bm{u}$ bits of length $K$ as inputs and outputs
$\bm{c}$ bits of size $N$. Then, there are many implementations of the
\verb|Encoder| class like the \verb|Encoder_polar| class, the
\verb|Encoder_LDPC| class, the \verb|Encoder_turbo| class, etc. To simplify the
instanciation of the non-static classes (like the encoders), many factory
classes have been created (for the encoders but not only). This type of classes
are regrouped in the \verb|aff3ct::factory| namespace. Their job is to simplify
the allocation of the module and tool objects.

\subsubsection{Module}

All the classes that are in the \verb|aff3ct::module| namespace inherit from the
\verb|Module| abstract class. The particularity of the module classes is that
they have to expose at least one method that can be called in the context of
digital communication chains. These specific methods are called \emph{tasks}.
For instance, the \verb|Encoder| class inherit from the \verb|Module| class and
defines the \verb|encode| method which is also a task. To be recognized as a
task, the \verb|encode| method has to be registered in the constructor of the
\verb|Encoder| class. The abstract \verb|Module| class defines and implements a
set of functions to perform this registering.

\begin{listing}[htp]
  \inputminted[frame=lines,linenos]{C++}{\curChapter/src/archi/task_registering.cpp}
  \caption{Example of task registering in the \texttt{Encoder} module class.}
  \label{lst:aff3ct_archi_task_registering}
\end{listing}

Listing~\ref{lst:aff3ct_archi_task_registering} presents an example of task
registering. The first step is to call the \verb|create_task| method that
takes the a name as the input parameter (line 8). This name is simply ``encode''
for the \verb|encode| method. Then, the \verb|create_task| method returns a
reference on the created task (\verb|ref_t|). Moreover, the input and output
sockets of the \verb|encode| method defined line 18 have to be declared. The
sockets are used to describe the input and output data of a task. The line 9 and
10 declare two sockets as there are two pointers in the prototype of the
\verb|encode| method. The first one (line 9) is an input socket declaration with
the \verb|create_socket_in| method while the second one (line 10) in an output
socket declaration with the \verb|create_socket_out| method. The socket sizes
and names are set accordingly to the characteristics of the $\bm{u}$ and
$\bm{c}$ vectors. Each time, the \verb|create_socket_x| method returns the id
(\verb|su| and \verb|sc|) of the socket in the task. Finally, a \emph{codelet}
is attached to the task (lines 11-17) thanks to the \verb|create_codelet|
method. This is the actual processing to execute when the task is called. The
purpose of the codelet is to be able to call the \verb|encode| method
independently of the current object instance. The prototype of the codelet is
always \verb|(Module &m, Task &t) -> int|.

Most of the time, when a developer wants to add a new module, he does not need
to register any task because it is already done for him. For instance, if a
developer wants to add a new encoder, he simply needs to inherit from the
proposed \verb|Encoder| class and to implement the \verb|encode| method defined
line 18.

\subsubsection{Tools}

The \verb|aff3ct::tools| namespace regroups many different types of processing.
The following is a synthetic list of the different families of components:
\begin{itemize}
  \item \textbf{Algorithmic \& Math}: the algorithmic components focus on the
    implementation of traditional algorithmic structures. For instance, it
    contains implementations of trees, matrices, histograms, etc. It also
    contains sorting and PRNG algorithms implementations. The math components
    regroup the interpolations, the Galois fields, the distributions, the
    integrations, etc.;
  \item \textbf{Channel code}: this type of tools regroups the processing
    implementations that are common to a single code family. For instance, the
    \verb|Polar_API| is located here;
  \item \textbf{Display}: these components are classes and functions dedicated
    to the display of the information in the terminal or in files. Statistic
    functions are located here as well as classed dedicated to the display of
    the BER and the FER performances;
  \item \textbf{Interface}: these abstract classes define interfaces. For
    instance, the \verb|Interface_reset| proposes a common interface for the
    \verb|reset| method. This way, all the classes inhering from this interface
    have exactly the same prototype for their implementation of the \verb|reset|
    method;
  \item \textbf{Performance}: this type of components is dedicated to high
    performance implementation. The vectorized reordering process presented in
    Section~\ref{sec:opt_vec_inter} is located here.
\end{itemize}
The above list is not exhaustive but is intended to give a representative
overview of what can be found in the tools.

\subsubsection{Factory}

In the OOP paradigm, the factory method pattern is dedicated to the the problem
of creating objects without having to specify the exact class of the object that
will be created. This is done by calling a method on the factory. In \AFFECT,
all the factories propose a \verb|build| method to this purpose. The return type
of the \verb|build| method is always an abstract class that regroups a sub-set
of implemented classes. Considering the \verb|factory::Source| class, first the
instantiation of this class is required. Then, the created object comes with a
list of public members that can be manually set or deduced from the command line
arguments. Once it is done the \verb|build| method can be called. This method
uses the public members (previously set) of the object to instantiate an object
of the \verb|module::Source| class. This object can be a
\verb|moudle::Source_random| object, a \verb|module::Source_user_binary| object,
etc.

\subsection{Software Functionalities}
\label{sec:aff3ct_features}

The \AFFECT software functionalities can be decomposed in three main parts: the
\textit{codecs}, the \textit{modems} and the \textit{channels}.

\begin{table}[htp]
  \centering
  \caption{List of the channel codes (codecs) supported in \AFFECT.}
  \label{tab:aff3ct_features_codecs}
% {\footnotesize%\resizebox{\linewidth}{!}{
  \begin{tabular}{ c | c | c }
  \multirow{2}{*}{\textbf{Channel Code}}  & \multirow{2}{*}{\textbf{Standard}} & \multirow{2}{*}{\textbf{Decoders}}        \\
                                          &                                    &                                           \\
  \hline
  \hline
  \multirow{5}{*}{{LDPC}}                 & 5G (data), Wi-Fi,                  & Scheduling: Flooding and H./V. Layered    \\
                                          & WiMAX, WRAN,                       & Sum-Product Algorithm (SPA, log-SPA)      \\
                                          & 10 Gigabit Eth.,                   & Min-Sum its derivatives (MS, NMS and OMS) \\
                                          & DVB-S2, CCSDS                      & Approximate Min-Star (AMS)                \\
                                          & etc.                               & Bit Flipping: GallagerA/B/E, PPBF, WBF    \\
  \hline
                                          &                                    & Successive Cancellation (SC)              \\
  Polar                                   & 5G                                 & Successive Cancellation List (SCL)        \\
  (\Arikan mono-kernel)                   & (control channel)                  & CRC-Aided SCL (CA-SCL, FA-SCL, PA-SCL)    \\
                                          &                                    & Soft Cancellation (SCAN)                  \\
  \hline
  Polar                                   &                                    & Successive Cancellation (SC)              \\
  (mono/multi-kernel                      & --                                 & Successive Cancellation List (SCL)        \\
  generic)                                &                                    & CRC-Aided SCL (CA-SCL, PA-SCL)            \\

  \hline
  \multirow{1}{*}{{Turbo Parallel}}       & LTE (3G, 4G),                      & Turbo BCJR                                \\
  (single and double                      & DVB-RCS,                           & Turbo BCJR + Early Termination (CRC)      \\
  binary)                                 & CCSDS, etc.                        & Post proc.: Flip aNd Check (FNC)          \\
  \hline
  \multirow{2}{*}{{Turbo Product}}        & \multirow{2}{*}{WiMAX (opt.)}      & \multirow{2}{*}{Turbo Chase-Pyndiah}      \\
                                          &                                    &                                           \\
  \hline
  \multirow{3}{*}{{BCH}}                  & CD, DVD,                           &                                           \\
                                          & SSD, DVB-S2,                       & Berlekamp-Massey + Chien search           \\
                                          & Bitcoin, etc.                      &                                           \\
  \hline
  \multirow{3}{*}{{Reed-Solomon}}         & CD, DVD,                           &                                           \\
                                          & SSD, DVB-T,                        & Berlekamp-Massey + Chien search           \\
                                          & ADSL, etc.                         &                                           \\
  \hline
  \multirow{1}{*}{{Convolutional}}        &                                    & BCJR - Maximum A Posteriori (MAP)         \\
  (single and double                      & NASA                               & BCJR - Linear Approximation (L-MAP)       \\
  binary)                                 &                                    & BCJR - Max-log Approximation (ML-MAP)     \\
  \end{tabular}
% }%}
\end{table}

The codecs are the main part of the toolbox. There is a broad range of supported
codes listed in Table~\ref{tab:aff3ct_features_codecs}. They naturally encompass
the encoders and decoders, but they can also include puncturing patterns to
shorten frames length according to some communication standards. Most of the
codec algorithms come from the literature, while the others have been designed
under \AFFECT~\cite{Tonnellier2016a,Tonnellier2016b,Tonnellier2017,
Leonardon2019}. In channel coding, the decoder is the most time-consuming
process, compared to the puncturing and the encoding processes. This is why a
specific effort is put on ensuring the high computing performance of the
decoders. Most of the decoding algorithms have thus been optimized to satisfy
high throughput and low latency constraints~\cite{LeGal2015a,Cassagne2015c,
Cassagne2016a,Cassagne2016b}. Those optimizations generally involve a vectorized
implementation, a tailored data quantization and the use of fixed-point
arithmetic.

\begin{table}[htp]
  \centering
  \caption{List of the modulations/demodulations (modems) supported in \AFFECT.}
  \label{tab:aff3ct_features_modems}
  %{\footnotesize%\resizebox{\linewidth}{!}{
  \begin{tabular}{ c | c | c }
  \multirow{2}{*}{\textbf{Modem}} & \multirow{2}{*}{\textbf{Standard}} & \multirow{2}{*}{\textbf{Information}}  \\
                                  &                                    &                                        \\
  \hline
  \hline
  \multirow{3}{*}{{N-PSK}}        & IEEE 802.16 (WiMAX)                &                                        \\
                                  & UMTS (2G, 2G+)                     & Phase-Shift Keying                     \\
                                  & EDGE (8-PSK), ...                  &                                        \\
  \hline
  \multirow{3}{*}{{N-QAM}}        & IEEE 802.16 (WiMAX)                &                                        \\
                                  & UMTS (2G, 2G+)                     & Quadrature Amplitude Modulation        \\
                                  & 3G, 4G, 5G, ...                    &                                        \\
  \hline
  \multirow{3}{*}{{N-PAM}}        & IEEE 802.16 (WiMAX)                &                                        \\
                                  & UMTS (2G, 2G+)                     & Pulse Amplitude Modulation             \\
                                  & 3G, 4G, 5G, ...                    &                                        \\
  \hline
  \multirow{2}{*}{{CPM}}          & GMSK, Bluetooth                    & Continuous Phase Modulation            \\
                                  & IEEE 802.11 FHSS                   & Coded (convolutional-based) modulation \\
  \hline
  \multirow{2}{*}{{OOK}}          & IrDA (Infrared)                    & On-Off Keying                          \\
                                  & ISM bands                          & Used in optical communication systems  \\
  \hline
  \multirow{2}{*}{{SCMA}}         & \multirow{2}{*}{Considered for 5G} & Sparse Code Multiple Access            \\
                                  &                                    & Multi-user modulation                  \\
  \hline
  \multirow{2}{*}{{User defined}} & \multirow{2}{*}{-}                 & Constellation and order can be         \\
                                  &                                    & defined from an external file          \\
  \end{tabular}
  %}%}
\end{table}

In typical communication chains, it is necessary to adapt the digital signal
to the physical support. This operation is performed by the modulator and
conversely by the demodulator. \AFFECT comes with a rich set of modems to this
purpose. Table~\ref{tab:aff3ct_features_modems} lists all the supported modems.
\AFFECT supports several coded modulation/demodulation schemes like the
Continuous Phase Modulation (CPM)~\cite{Aulin1981a,Aulin1981b} and the Sparse
Code Multiple Access (SCMA) modulation~\cite{Nikopour2013,Ghaffari2017,
Ghaffari2019} (many codebooks are supported~\cite{AlteraSCMA,Wu2015,Cheng2015,
Zhang2016,Klimentyev2016,Song2017,Klimentyev2017}). It allows to easily combine
and evaluate the channel codes with several types of modulations. In the case of
the CPM, analogical wave shapes are also simulated. The other modulation schemes
are at the digital level.

\begin{table}[htp]
  \centering
  \caption{List of the channel models supported in \AFFECT.}
  \label{tab:aff3ct_features_channels}
  % {\footnotesize%\resizebox{\linewidth}{!}{
  \begin{tabular}{ c | c | c }
  \multirow{2}{*}{\textbf{Channel}}      & \multirow{2}{*}{\textbf{Multi-user}} & \multirow{2}{*}{\textbf{Information}}          \\
                                         &                                      &                                                \\
  \hline
  \hline
  \multirow{2}{*}{{AWGN}}                & \multirow{2}{*}{Yes}                 & \multirow{2}{*}{Additive White Gaussian Noise} \\
                                         &                                      &                                                \\
  \hline
  \multirow{2}{*}{{BEC}}                 & \multirow{2}{*}{No}                  & \multirow{2}{*}{Binary Erasure Channel}        \\
                                         &                                      &                                                \\
  \hline
  \multirow{2}{*}{{BSC}}                 & \multirow{2}{*}{No}                  & \multirow{2}{*}{Binary Symmetric Channel}      \\
                                         &                                      &                                                \\
  \hline
  \multirow{2}{*}{{Rayleigh}}            & \multirow{2}{*}{Yes}                 & \multirow{2}{*}{Flat Rayleigh fading channel}  \\
                                         &                                      &                                                \\
  \hline
  \multirow{2}{*}{{User defined}}        & \multirow{2}{*}{No}                  & User can import noise samples                  \\
                                         &                                      & from an external file                          \\
  \end{tabular}
  %}%}
\end{table}

For simulation purposes, it is crucial to emulate the behavior of the physical
layer. This is the role of the channel. There are many possible configurations
depending on the physics phenomena to simulate.
Table~\ref{tab:aff3ct_features_channels} reports all the supported channels. The
channels involve complex floating-point computations. It is frequent to use
exponential and trigonometric operations. Those types of operations cost a large
amount of CPU cycles to be computed. As for the decoders, the channels have been
carefully optimized based on branch instructions reduction and massive
vectorization.

Many additional functional functionalities available are skipped here for
concision.

\subsection{Example of Library Use}
\label{sec:aff3ct_library_example}

As a FEC library, \AFFECT can be used programmatically, for instance in
real-time contexts or to build specific functional simulations. \AFFECT blocks
can be used in external projects without restriction. Compute intensive blocks
are optimized and vectorized to run fast on a single core.

% The library is thread-safe; however, it is not multi-threaded by itself, in
% contrast to the simulator. Instead, it is the responsibility of the user to
% manage multi-threading.

\begin{figure}[htp]
  \centering
  \includegraphics{\curChapter/fig/use_cases/library_task_module/library_task_module}
  \caption{Simulation of a digital communication chain using the \AFFECT
    library.}
  \label{fig:aff3ct_library_task_module}
\end{figure}

In this section we propose an illustrative example of the \AFFECT library
utilization. The objective is to simulate the digital communication chain shown
in Figure~\ref{fig:aff3ct_library_task_module}. In the figure, the represented
modules correspond to the classes presented in the previous section. A module
can also be seen as a set of related tasks sharing some characteristics. For
instance, the \textit{modem} module contains the \textit{modulate} and
\textit{demodulate} tasks. Then, a task is an elementary processing performed on
some data. For instance, \textit{decode} or \textit{modulate} are tasks. The
tasks are characterized by their \textit{sockets}. A socket of a task defines an
entry point through which the task will consume and/or produce data. There are
three kinds of sockets: \textit{input}, \textit{output} and
\textit{input/output}, following a philosophy close to \emph{ports} in
component-based development approaches. As a rule, a task is always a
\emph{verb} and a module is always a \emph{noun}.
Figure~\ref{fig:aff3ct_library_task_module} presents common modules and tasks
typically found in a basic communication chain. It shows that the number of
tasks per module can vary depending on the module type.

\begin{listing}[htp]
  \inputminted[frame=lines,linenos]{C++}{\curChapter/src/use_cases/library/modules_allocation.cpp}
  \caption{Example of modules allocation with the \AFFECT library.}
  \label{lst:aff3ct_library_modules_allocation}
\end{listing}

The first step is to allocate the modules. In
Listing~\ref{lst:aff3ct_library_modules_allocation} we chose to allocate modules
on the stack, but it is also possible to do the same on the heap. $K$ is the
number of information bits, $N$ is the frame size and $E$ is the number of
erroneous frames to simulate. In this basic example, a repetition code is
selected, it simply repeats the information bits $N/K$ times.

\begin{listing}[htp]
  \inputminted[frame=lines,linenos]{C++}{\curChapter/src/use_cases/library/sockets_binding.cpp}
  \caption{Example of sockets binding with the \AFFECT library.}
  \label{lst:aff3ct_library_sockets_binding}
\end{listing}

The next step is to bind the sockets of successive tasks together (see
Listing~\ref{lst:aff3ct_library_sockets_binding}): The \textit{source} module
output socket \verb|module::src::sck::generate::u| is connected to the input
socket \verb|module::enc::sck::encode::u| of the \textit{encoder}, and so
on, for all the sockets of the tasks.

\begin{listing}[htp]
  \inputminted[frame=lines,linenos]{C++}{\curChapter/src/use_cases/library/tasks_execution.cpp}
  \caption{Example of tasks execution with the \AFFECT library.}
  \label{lst:aff3ct_library_tasks_execution}
\end{listing}

The simulation is then started and each task is executed. In
Listing~\ref{lst:aff3ct_library_tasks_execution}, the whole communication chain
is executed multiple times, until the $E = 100$ frame error limit is achieved.

To propose an easy to use interface, sockets and tasks can be selected through
the \verb|[]| operator, which takes a \Cxx strongly typed enumerate. This way it
is possible to specialize the code depending on whether it is a socket or a
task. Strongly typed enumerates are checked at compile time (contrary to
standard enumerates), making it impossible to use wrong values. Complete
examples of the \AFFECT library utilization are available on
GitHub\footnote{\AFFECT library examples: \url{https://github.com/aff3ct/my_project_with_aff3ct/}}.

The \AFFECT library has also been used to prototype FPGA decoders.
In~\cite{Cassagne2017a}, a BCH decoder is implemented on a Xilinx\R Artix-7
FPGA. \AFFECT simulates the transmission of a first frame. The noisy frame is
then sent to the FPGA using the UART protocol. The hardware BCH decoder
processes the frame and sends it back to the PC. \AFFECT can then proceed and
perform the rest of the processing for this frame. Once the number of residual
errors is updated, \AFFECT starts with a new frame, and so on. The decoding
performance appears to be equivalent to the performance of the pure software
simulation which shows that the hardware BCH decoder is correctly implemented.

\subsection{MATLAB Wrapper}

In the signal processing community it is common to use MATLAB to implement and
to evaluate new algorithms or/and configurations. More specifically, the
\emph{communications toolbox} is often used. This toolbox contains a large set
of algorithms of digital communication systems but they often lack of
efficiency, especially for the channel decoder implementations. Knowing that,
we developed a wrapper MATLAB to enable calls to the compiled \AFFECT library.
The wrapper can be seen as a new MATLAB toolbox that proposes faster decoder
implementations than the traditional MATLAB communications toolbox. \AFFECT
also comes with channel decoders that are not available in the standard
communications toolbox.

\begin{listing}[htp]
  \inputminted[frame=lines,linenos]{matlab}{\curChapter/src/use_cases/library/repetition_chain.m}
  \caption{Example of the \AFFECT MATLAB wrapper.}
  \label{lst:aff3ct_library_matlab}
\end{listing}

The proposed MATLAB wrapper is automatically generated for the \AFFECT headers.
The Clang compiler is used to generate the Abstract Syntax Tree (AST) of the
\AFFECT source code and a Python script extracts useful classes and methods.
These data are stored in a JSON database. Then, an other Python script as been
written to generate \Cxx and MATLAB codes that effectively perform the interface
between the \AFFECT library and MATLAB. Listing~\ref{lst:aff3ct_library_matlab}
shows the same example of code as in Section~\ref{sec:aff3ct_library_example}
but in MATLAB. At the time of the writing, the MATLAB wrapper has not been
publicly released yet.

\section{Simulation of Digital Communication Algorithms}

\subsection{A Simulator Application on Top of the Library}

The \AFFECT toolbox comes with a dedicated functional
simulator~\cite{Cassagne2017}. It is based on the \AFFECT library presented
before. We remarked that the functional simulation chain used in the literature
are very often similar. For this reason, the simulation chain presented in
Fig.~\ref{fig:aff3ct_library_task_module} has been enriched and implemented. The
proposed simulator supports multi-threading to take advantage of the today CPUs
multi-core architecture. It is also able to run on supercomputers and comes with
a multi-node implementation based on the well-known HPC Message Passing
Interface (MPI). The multi-core and multi-node performance of the \AFFECT
simulator will be evaluated later in Section~\ref{sec:eval_simu}.

\subsection{Example of Simulator Use}
\label{sec:aff3ct_simulator_example}

One of the main advantage of the \AFFECT simulator is to come with a common
interface for many channel code families. It is also possible to evaluate the
error-rate performance of these code families on various configurations thanks
to the supported modems and channel models. It also becomes easier to compare
different code families with each other.

\begin{listing}[htp]
  \inputminted[frame=lines]{bash}{\curChapter/src/use_cases/simulator/input.txt}
  \caption{Example of an \AFFECT simulator command.}
  \label{lst:aff3ct_simulator_input}
\end{listing}

The \AFFECT simulator is a command line executable and all its possible
parameters are exhaustively documented\footnote{\AFFECT documentation:
\url{https://aff3ct.readthedocs.io}}. Listing~\ref{lst:aff3ct_simulator_input}
proposes to simulate a $(2048,1723)$ polar code from 1 dB to 4 dB with a step of
1 dB (c.f. Section~\ref{sec:ctx_simulation}). By default, the AWGN channel is
selected as well as the BPSK modulation. Then the SC decoder is specified. For a
given SNR, by default the simulation stops when more than 100 erroneous frames
are detected.

\begin{listing}[htp]
  \inputminted[frame=lines,linenos]{console}{\curChapter/src/use_cases/simulator/output.txt}
  \caption{Example of an \AFFECT simulator output.}
  \label{lst:aff3ct_simulator_output}
\end{listing}

Listing~\ref{lst:aff3ct_simulator_output} shows the simulation results
corresponding to the \AFFECT command given in
Listing~\ref{lst:aff3ct_simulator_input} (note that some details have been
removed for concision). \verb|FRA| stands for the number of simulated frames,
while \verb|BE| and \verb|FE| are the number of bit and frame errors. The
simulator output is clear and adapted to post processing: lines starting with a
hashtag can be skipped.

\subsection{In-depth Parameter Exploration}

One of the main strength of the \AFFECT simulator is to enable the exploration
of various configurations. In this section, a tour of the possible parameters is
given. As shown in Section~\ref{sec:aff3ct_features}, many code families are
supported. To the best of our knowledge the \AFFECT toolbox regroups more
channel codes than all the other existing libraries (c.f.
Section~\ref{sec:aff3ct_related_works}). Each of these code can be simulated
over many channel models (BEC, BSC, AWGN and Rayleigh) and modulation schemes
(PSK, QAM, PAM, OOK, CPM and SCMA). In this thesis the channel model is always
the AWGN and the modulation scheme is almost always a BPSK. It can also be the
SCMA modulation and it will be explicitly mentioned in the latter case. For each
channel code, many decoding algorithms and their corresponding approximations
can be compared.

\begin{figure}[htp]
  \centering
  \includegraphics[width=0.7\textwidth]{\curChapter/fig/ldpc/update_rules/update_rules}
  \caption
    [Decoding performance of the LDPC BP algorithm depending on the update
     rules.]
    {Decoding performance of the LDPC BP algorithm depending on the update rules
     (horizontal layered scheduling). 40 iterations, IEEE 802.16e (WiMAX)
     $\mathcal{H}$ parity matrix ($N=2304$, $R=1/2$).}
  \label{plot:aff3ct_ldpc_update_rules}
\end{figure}

For instance, in Fig.~\ref{plot:aff3ct_ldpc_update_rules}, the LDPC belief
propagation (BP) algorithm is considered with an horizontal layered scheduling.
The $\mathcal{H}$ parity matrix has been taken from the WiMAX standard
($N=2304$, $R=1/2$). The impact of various update rules on the decoding
performance is observed. As explained in Section~\ref{sec:ctx_ldpc}, the Min-Sum
(MS) is an approximation of the Sum-Product Algorithm (SPA) and leads to a
performance loss. The Offset Min-Sum (OMS) and the Normalized Min-Sum (NMS) are
improvements of the MS that enable to recover a part of the SPA decoding
performance.

\begin{figure}[htp]
  \centering
  \includegraphics[width=0.7\textwidth]{\curChapter/fig/ldpc/scheduling/scheduling}
  \caption
    [Decoding performance of the LDPC BP algorithm depending on the scheduling.]
    {Decoding performance of the LDPC BP algorithm depending on the scheduling
     policies. Flooding (BP-F), horizontal layered (BP-HL) and vertical layered
     (BP-VL) scheduling are considered (SPA update rules). IEEE 802.16e (WiMAX)
     $\mathcal{H}$ parity matrix ($N=2304$, $R=1/2$).}
  \label{plot:aff3ct_ldpc_scheduling}
\end{figure}

In Fig~\ref{plot:aff3ct_ldpc_scheduling} only the SPA is considered
and the decoding performance of various scheduling policies is compared. The
results show that the convergence of the layered scheduling policies is faster
than the traditional flooding scheduling for the same number of iterations.
Increasing the number of iterations improves the decoding performance while it
increases the computation complexity of the decoder. It is up to the system
designer to chose the right configuration.

\begin{figure}[htp]
  \centering
  \includegraphics[width=0.70\textwidth]{\curChapter/fig/polar/scl_adaptive/scl_adaptive}
  \caption
    [FER and throughput of the polar fully and partially adaptive SSCL
     decoders.]
    {Frame Error Rate performance and throughput of the polar Fully and
     Partially Adaptive SSCL decoders (FA and PA). $N = 2048$, $K = 1723$ and
     32-bit CRC (GZip). Throughputs have been measured on the Intel\R Core\TM
     i5-6600K CPU.}
  \label{plot:aff3ct_polar_scl_adaptive}
\end{figure}

Fig.~\ref{plot:aff3ct_polar_scl_adaptive} is an example of polar decoders
working on a $N = 2048$ and $K = 1723$ code. The FA-SSCL and PA-SSCL decoders
have the same decoding performance for the same list size $L$. However, the
throughputs are different depending on the SNR zone. This is an other example of
possible exploration with the \AFFECT simulator. Depending on the targeted SNR
range, it is more interesting to choose either decoder.

\begin{figure}[htp]
  \centering
  \includegraphics[width=0.7\textwidth]{\curChapter/fig/turbo/quantification/quantification}
  \caption
    [FER of the turbo decoder for $K = 6144$ (6 iterations) and
     $R=1/3$.]
    {Frame Error Rate of the turbo decoder for $K = 6144$, $R=1/3$ and 6
     decoding iterations. Enhanced max-log-MAP algorithm ($\alpha = 0.75$).}
  \label{plot:aff3ct_turbo_quantification}
\end{figure}

An other important aspect to observe is the impact of the quantification on the
decoding performance. To increase the throughput or to decrease the latency of
a signal processing, it is common to reduce the amplitude of the data and to
use a fixed-point representation that can be shorter and more efficient than a
floating-point representation. This is true for hardware decoders as well as for
high performance software implementations. In
Fig.~\ref{plot:aff3ct_turbo_quantification}, the biggest turbo code from the LTE
standard is proposed ($K = 6144$, $R = 1/3$). The same code is evaluated over 3
different data representations. \emph{float} is a 32-bit decoder working on
floating-point data, this is the reference. \emph{int-16} and \emph{int-8}
decoders are working on fixed-point data, respectively on 16 bits and on 8 bits.
The $Q_{s,v}$ corresponds to the quantification format of the decoder input LLRs
(c.f. Eq.~\ref{eq:opt_simu_quantizer}). $s$ is the number of bits of the
quantized number, including $v$ bits for the fractional part. The quantification
format is a parameter of the \AFFECT simulator. In
Fig.~\ref{plot:aff3ct_turbo_quantification}, the 16-bit quantification is able
to match the reference decoding performance while there is a little performance
degradation in 8-bit.

\begin{figure}[htp]
  \centering
  \includegraphics[width=0.70\textwidth]{\curChapter/fig/scma/fec/fec_1_2}
  \caption
    [FER evaluation of the SCMA MPA and E-MPA demodulators.]
    {FER evaluation of the SCMA MPA and E-MPA demodulators combined with LDPC,
     polar and turbo codes ($K \approx 2048$ and $R \approx 1/2$).
     The LDPC $\mathcal{H}$ parity matrix comes from the MacKay personal
     webpage\footnote{MacKay's webpage: \url{http://www.inference.org.uk/mackay/codes/data.html}}.
     The LDPC decoder used is the BP-HL with the SPA update rules (100
     iterations). The polar code is build from the Gaussian Approximation
     technique. The polar decoder is the CA-SSCL decoder with $L=32$ (the 32-bit
     GZIP CRC is used). The turbo code comes from the LTE standard and it is
     punctured to support $R \approx 1/2$. The turbo decoder is the EML-MAP with
     $\alpha = 0.75$ and 6 iterations.}
  \label{plot:aff3ct_scma_fec}
\end{figure}

Fig.~\ref{plot:aff3ct_scma_fec} demonstrates complex simulation scenarios where
the BPSK modulation is replaced by the SCMA modulation. The MPA demodulator and
its E-MPA approximation are combined with the LDPC, the polar and the turbo
codes. The purpose of these curves is not to directly confront the 3 channel
code families even if we tried to select codes that have close enough
characteristics. The results show that the E-MPA approximation leads to a
performance degradation for each channel code family but this negative impact is
higher for the selected LDPC code than for the selected polar and turbo codes.

The objective of this section is not to be exhaustive and many more parameters
could be explored. However it gives a representative overview of the large
variety of parameters that can be tweaked in our proposed simulator.

\subsection{BER/FER Comparator and Pre-simulated Results} % Pre-simulated Results?

% TODO: des chiffres des chiffres a dit Denis

The \AFFECT output (c.f. Listing~\ref{lst:aff3ct_simulator_output}) is not
adapted to see the error-rate performance at a glance. And it is even more
complicated to compare two or more simulation outputs with each other.
Traditionally the BER and FER decoding performances are presented in a form of
graphical curves (c.f. Fig.~\ref{fig:ctx_bfer}). It is then much easier to
compare their decoding performance.

% To this purpose, a portable tool named \emph{PyBER} has been developed.
% This tool is a standalone program written in Python. It is capable to read the
% \AFFECT simulator outputs but it can also easily adapt to other formats. PyBER
% extensively uses the \emph{PyQtGraph} library to plot the BER/FER curves. PyBER
% allows to browse the file system and to select one or more text files to
% display. It is also possible to zoom on the curves and the simulation details of
% each curve are presented in a dedicated panel. PyBER can plot in real-time the
% curves that are currently simulated (there is no need to reload the \AFFECT
% output files). Like all the \AFFECT tools, PyBER is open-source and can be used
% without any limitations\footnote{PyBER repository:
% \url{https://github.com/aff3ct/PyBER}}.

To this purpose, the BER/FER comparator has been introduced. It is available
online on the \AFFECT website\footnote{\AFFECT online BER/FER comparator:
\url{http://aff3ct.github.io/comparator.html}}. It is capable to read the
\AFFECT simulator outputs but it can also easily adapt to many other formats.
The comparator is written in JavaScript. By default, a database of \AFFECT
pre-simulated results is already available. This database is the same as
the error-rate reference results used in the regression tests (c.f.
Section~\ref{sec:aff3ct_ci_cd}). Then, these references are classified according
to different characteristics: the code type, the modem type, the channel type,
the frame size ($N$) and the code rate ($R$). There is also a search bar to
facilitate the curves selection process. At the time of the writing,
approximatively 500 BER/FER references are available. For each reference, it
possible to get the corresponding command line in the \AFFECT simulator. This
way it is very easy to reproduce the reference results or to modify the command
line parameters. The reference curves that have been published are marked with
their Digital Object Identifier (DOI). It is then possible to search a specific
result from its DOI in the search bar. Note that with the online BER/FER
comparator it is very easy to share the selected curves with other people thanks
to a permalink. The default proposed database is the \AFFECT database
(error-rate references) but it is also possible to enable the database of the
Kaiserslautern University: we wrote a script to automatically parse their online
database\footnote{Kaiserslautern ML BER/FER database:
\url{https://www.uni-kl.de/channel-codes/ml-simulation-results/}}.

\subsection{Continuous Integration and Continuous Delivery}
\label{sec:aff3ct_ci_cd}

\AFFECT's development leverages streamlined Continuous Integration (CI) process.
Each new commit the version control repository (Git) triggers a comprehensive
sequence of tests to catch potential regressions. These tests are combined with
Continuous Delivery (CD) tasks to deliver new \AFFECT builds automatically.

\begin{figure}[htp]
  \centering
  \includegraphics{\curChapter/fig/ci_cd/pipeline/pipeline}
  \caption{\AFFECT continuous integration and continuous delivery pipeline.}
  \label{fig:aff3ct_ci_cd_pipeline}
\end{figure}

Fig.~\ref{fig:aff3ct_library_task_module} shows the different stages of the
\AFFECT CI/CD pipeline. The \emph{analysis} stage contains jobs that can be
executed without compiling the \AFFECT binaries. The \emph{build} stage is a set
of compilation jobs. The \emph{check} stage proposes verification jobs that
require the \AFFECT binaries. The \emph{test} stage is composed by a set of jobs
focusing on regression testing . The \emph{coverage} stage measures the
percentage of the \AFFECT source code used in the regression tests. Finally, the
\emph{Deploy} stage contains jobs that are used to push the pipeline results on
various targets.

\paragraph{Analysis}

In this stage, static analysis tools are run on the \AFFECT source code
in order to get some metric on the code quality. To this purpose
\textit{cppcheck}, \textit{scan-build} and \textit{clang-tidy} are used. This
stage also contains a job dedicated to the compilation of the documentation,
this documentation will later be packed in the deployed builds if the pipeline
succeed. Moreover, a script dedicated to the \AFFECT headers is also executed as
well as a script that check if the Git sub-modules are valid. The execution time
of the analysis stage is relatively short. If one of these jobs fails, then the
pipeline stop.

\paragraph{Build}

The main purposes of the build stage are: 1) verify that the \AFFECT source code
compiles on many compilers and operating systems; 2) compile static and portable
binaries to deliver new builds at the end of the pipeline. On Windows, the GNU
compiler and the Microsoft Visual compiler are tested. On Linux, the GNU
compiler, the Clang compiler, and the Intel compiler are  tested. On macOS, only
the Clang compiler is tested at this time. Specific SSE4.2 and AVX2 static
binaries are compiled for the 3 operating systems.

\paragraph{Check}

In the check stage, the \emph{debug-parser} tool is verified on the compiled
\AFFECT binaries. This tool is a Python script that post-process the \AFFECT
simulation debug output to show the contain of the data between the tasks. A
second job checks if the documentation is compatible with the help of the
\AFFECT simulator binary. A Python script checks if the entries in the
documentation corresponds to the one present in the simulator help to prevent
from desynchronization.

\paragraph{Test}

The regression tests are split according to the different channel code families.
Each job focuses on a single family of code. Error-rate reference results that
have been recorded from previous simulations are replayed. A Python script
compares the reference results with the current simulator outputs. If the
references and the current outputs are close enough, then the tests are
validated. This tests are very important and ensure that the previously
implemented features are still working after many source code modifications.
When a developer add a new feature it is to its responsibility to add the
corresponding regression tests in the CI.

\paragraph{Coverage}

To compute the code coverage, the GNU compiler \verb|--coverage| option combined
to the \emph{gcov} tool are used. A specific \AFFECT simulator binary is
compiled and run on all the error-rate references. To reduce the execution time,
only one frame per SNR is simulated. At the time of the writing, the regression
tests are covering about 60\% of the \AFFECT source code.

\paragraph{Deploy}

The deploy stage is in charge to regroup the \AFFECT compiled binaries
(simulator and library) with the documentation, the error-rate references, some
configuration files, etc. There are two builds for each operating system, one in
SSE4.2 and the other in AVX2. Once the build is ready, an entry in the \AFFECT
website is automatically added, committed and pushed. Then the users can
directly download the last builds on the \AFFECT download page\footnote{\AFFECT
download page: \url{http://aff3ct.github.io/download.html}}. An other job is in
charge to push the \AFFECT build on our Ubuntu Personal Package Archives
(PPA)\footnote{\AFFECT Ubuntu PPA: \url{https://launchpad.net/~aff3ct/+archive/ubuntu/aff3ct-dev}}.
Once the \AFFECT PPA is added to the Ubuntu system, it is trivial to install the
last \AFFECT builds:
\verb|sudo apt install aff3ct-bin aff3ct-doc libaff3ct libaff3ct-dev|. Only
the SSE4.2 build is pushed to the Ubuntu PPA as it maximizes the number of
laptops that can execute it. Finally, a last job send the various static
analysis and code coverage reports to a SonarQube instance\footnote{\AFFECT
SonarQube: \url{https://sonarqube.inria.fr/sonarqube/dashboard?id=storm:aff3ct:gitlab:master}}.
SonarQube is a web control panel for the quality of the source code.

The \AFFECT pipeline instances are publicly available online\footnote{\AFFECT
pipelines: \url{https://gitlab.com/aff3ct/aff3ct/pipelines}}. The CI/CD process
enables us to safely and confidently integrate contributed features and
improvements from the community to \AFFECT. It also helps to keep the code
review time by the core development team low-enough to swiftly integrate such
contributions into the master branch.

\section{Impact and Community}
\label{sec:aff3ct_impact}

\AFFECT is currently used in several industrial contexts for simulation purposes
(Turbo concept, Airbus, Thales, Huawei) and for specific developments (CNES,
Schlumberger, Airbus, Thales, Orange), as well as in academic projects (NAND
French National Agency project, IdEx CPU). The MIT license used in the project
is very permissive and gives confidence to industrial and academic partners, who
can then invest themselves and reuse parts of \AFFECT in their own projects
without any restrictions.

\AFFECT has been cited in scientific publications and this paragraph aims to
give an overview of its utilization. Many works are using the \AFFECT simulator
as a reference for the decoding performance~\cite{Pignoly2018,
Poulenard2018,Ghanaatian2018,Wang2019,Hsieh2020,Rush2020,Duffy2020}. In other
works, \AFFECT has been enriched to support new features:
in~\cite{Leonardon2018b} the P-EDGE generator tool (c.f.
Section~\ref{sec:opt_polar_pedge}) has been modified to generate Transport
Triggered Architecture (TTA $\approx$ VLIW) instructions while
in~\cite{Tasdighi2020} a new LDPC code construction method is proposed and
directly implemented in the \AFFECT simulator. In some cases \AFFECT is used as
a library where some sub-parts of the toolbox are reused or some methodologies
are extracted~\cite{Florian2018,Cavatassi2019a,Cavatassi2019b,Ercan2020}. A
non-negligible part of the citations are comparisons with the fast decoder
implementations described in this manuscript~\cite{Zeng2017,Leonardon2018a,
Guermouche2019,LeGal2019a,Shen2020}. Finally, in many works, \AFFECT is simply
discussed and considered but not directly used~\cite{Debbabi2016,Debbabi2016a,
Ercan2017,Natarajan2018,Cenova2019,Krainyk2019,Vameghestahbanati2019,
Mohammed2019,Shaheen2019,Aly2019,Delomier2020}.

As \AFFECT is open-source, some of the previous works has been integrated inside
the toolbox. However, it worth mentioning that \AFFECT is more often simply used
than enriched. But, we strongly believe that the proposed philosophy can lead to
a growing community of users and contributors. This is already demonstrated with
the increasing activity on the public issue tracker\footnote{\AFFECT issue
tracker: \url{https://github.com/aff3ct/aff3ct/issues}}. We also know that
bigger open-source projects, like GNU Radio, are considering to integrate some
of the \AFFECT fast decoders.

\section{Conclusion}

In this chapter, \AFFECT, our open-source toolbox dedicated to digital
communication algorithms, is presented. First the focus is made on the library
with a robust software architecture that enables the algorithmic heterogeneity.
Many channel codes are supported like the LDPC codes, the polar codes, the turbo
codes, the TPC codes, the convolutional codes, the BCH codes, the RS codes, etc.
To the best of our knowledge, \AFFECT is the library with the best support for
channel coding algorithms. \AFFECT also comes with multiple channel models
(AWGN, Rayleigh, BEC, BSC, etc.) and modulation schemes (PSK, QAM, PAM, OOK,
CPM, SCMA, etc.). All these efficient algorithm implementations can be simply
used from clear interfaces and an examples of library usages are given in native
\Cxx or by using the MATLAB wrapper.

\AFFECT is not only a library and comes with a very complete BER/FER simulator.
All the previously enumerated features can be simulated over various parameters.
The simulator takes advantage of the CPUs multi-core architecture to reduce the
restitution time. A tour of the possible exploration is given. Many parameters
can be tweaked like the number of decoding iterations, the approximations in the
algorithm implementation, the quantification of the LLRs in the decoders, etc.
Some of these parameters are presented according to the decoders and
demodulators introduced in Chapter~\ref{chap:ctx} and Chapter~\ref{chap:opt}.
The \AFFECT simulator is a unique tool that enable an unprecedented level of
exploration.

\AFFECT puts all the means for the reproducible science. A BER/FER comparator
tools has been developed to easily search in a database of 500 pre-simulated
BER/FER references. All there references are results simulated with \AFFECT and
that can be reproduced. To this purpose, a pipeline of test has been
implemented: each time there is a modification in the source code, the database
of references is replayed to avoid regressions. These tests are also ran on
multiple architectures (x86 and ARM\R) and operating systems (Windows, macOS and
Linux) to ensure that the portability is always conserved.

The last section discusses about the \AFFECT impact in the community. It is
shown that more and more users are adopting the toolbox in both industrial
and academic contexts. The application contexts are varied and range from
decoding performance validations to the use of specific sub-parts of the
library. External contributions are still rare.
